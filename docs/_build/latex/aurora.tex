%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}
\hypersetup{bookmarksdepth=3}

\title{aurora Documentation}
\date{Oct 21, 2020}
\release{1.0.0}
\author{Francesco Sciortino}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


Github repo: \sphinxurl{https://github.com/fsciortino/aurora}


\chapter{Overview}
\label{\detokenize{index:overview}}
{\hyperref[\detokenize{aurora:module-aurora}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{aurora}}}}} is a 1.5D modern forward model for radial particle transport in magnetically confined plasmas. It inherets many of its methods from the historical STRAHL code and has been thoroughly benchmarked with it. The core of {\hyperref[\detokenize{aurora:module-aurora}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{aurora}}}}} is written in Python3 and Fortran90, with a Julia interface also under development.

{\hyperref[\detokenize{aurora:module-aurora}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{aurora}}}}} includes Python functionality to create inputs and read/plot outputs. OMFIT users may access this functionality via the OMFIT STRAHL module. {\hyperref[\detokenize{aurora:module-aurora}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{aurora}}}}} was designed to be as efficient as possible in iterative workflows, where different diffusion and convection coefficients are run through the code in order to match some experimental observations. For this reason, {\hyperref[\detokenize{aurora:module-aurora}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{aurora}}}}} keeps all data in memory and avoids any I/O during operation.

A number of standard tests and examples are provided using a real set of Alcator C\sphinxhyphen{}Mod kinetic profiles and geometry. In order to interface with EFIT gEQDSK files, {\hyperref[\detokenize{aurora:module-aurora}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{aurora}}}}} makes use of the \sphinxcode{\sphinxupquote{omfit\_eqdsk}} package, which offers flexibility to work with data from many devices worldwide. Users may easily substitute this dependence with different magnetic reconstruction packages and/or postprocessing interfaces, if required.

{\hyperref[\detokenize{aurora:module-aurora}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{aurora}}}}} provides convenient interfaces to load a default namelist via {\hyperref[\detokenize{aurora:module-aurora.default_nml}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{default\_nml()}}}}}, modify it as required and then pass the resulting namelist dictionary into the simulation setup. This is in the main class of {\hyperref[\detokenize{aurora:module-aurora}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{aurora}}}}}, {\hyperref[\detokenize{aurora:aurora.core.aurora_sim}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{aurora\_sim}}}}}, which allows creation of radial and temporal grids, interpolation of atomic rates, preparation of parallel loss rates at the edge, etc.

The library in {\hyperref[\detokenize{aurora:module-aurora.atomic}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{atomic()}}}}} provides functions to load and interpolate atomic rates from ADAS ADF\sphinxhyphen{}11 files, as well as from ADF\sphinxhyphen{}15 photon emissivity coefficients (PEC) files. PEC data can alternatively be computed using the collisional\sphinxhyphen{}radiative model of CollRadPy, using methods in {\hyperref[\detokenize{aurora:module-aurora.radiation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{radiation()}}}}}.

{\hyperref[\detokenize{aurora:module-aurora}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{aurora}}}}} was born as a fast forward model of impurity transport, but it can do much more. For example, it may be helpful for parameter scans in modeling of future devices. The {\hyperref[\detokenize{aurora:aurora.radiation.radiation_model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{radiation\_model()}}}}} method allows one to use ADAS atomic rates and given kinetic profiles to compute line radiation, bremsstrahlung, continuum and soft\sphinxhyphen{}x\sphinxhyphen{}ray\sphinxhyphen{}filtered radiation. Ionization equilibria can also be computed using the {\hyperref[\detokenize{aurora:module-aurora.atomic}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{atomic()}}}}} methods, thus enabling simple “constant\sphinxhyphen{}fraction” models where the total density of an impurity species is fixed to a certain percentage of the electron density.


\chapter{Installation}
\label{\detokenize{index:installation}}
To obtain the latest version of the code, it is recommended to git\sphinxhyphen{}clone the repo
\sphinxurl{https://github.com/fsciortino/aurora}
and run the makefile from the command line.

The latest stable version of the code can also be obtained via:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{aurora}
\end{sphinxVerbatim}

of from Anaconda Cloud:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{conda} \PYG{n}{install} \PYG{n}{aurora}
\end{sphinxVerbatim}


\chapter{Demos/Examples}
\label{\detokenize{index:demos-examples}}
A number of demonstrations and examples are available in the {\hyperref[\detokenize{aurora:module-aurora}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{aurora}}}}} “examples” directory. These show how to load a default namelist, modify it with specific kinetic profiles, load a magnetic equilibrium, set up an {\hyperref[\detokenize{aurora:module-aurora}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{aurora}}}}} object and run. A number of plotting tools and postprocessing scripts to calculate radiation are also presented.


\chapter{Questions? Suggestions?}
\label{\detokenize{index:questions-suggestions}}
Please contact sciortino\sphinxhyphen{}at\sphinxhyphen{}psfc.mit.edu for any questions. Suggestions and collaborations are more than welcome!


\chapter{Package Reference}
\label{\detokenize{index:package-reference}}

\section{aurora package}
\label{\detokenize{aurora:aurora-package}}\label{\detokenize{aurora::doc}}

\subsection{Submodules}
\label{\detokenize{aurora:submodules}}

\subsection{aurora.core module}
\label{\detokenize{aurora:module-aurora.core}}\label{\detokenize{aurora:aurora-core-module}}\index{module@\spxentry{module}!aurora.core@\spxentry{aurora.core}}\index{aurora.core@\spxentry{aurora.core}!module@\spxentry{module}}
This module includes the core class to set up simulations with \sphinxcode{\sphinxupquote{eqtools}}. The {\hyperref[\detokenize{aurora:aurora.core.aurora_sim}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{aurora\_sim}}}}} takes as input a namelist dictionary and a g\sphinxhyphen{}file dictionary (and possibly other optional argument) and allows creation of grids, interpolation of atomic rates and other steps before running the forward model.
\index{aurora\_sim (class in aurora.core)@\spxentry{aurora\_sim}\spxextra{class in aurora.core}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.core.aurora_sim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{aurora.core.}}\sphinxbfcode{\sphinxupquote{aurora\_sim}}}{\emph{\DUrole{n}{namelist}}, \emph{\DUrole{n}{geqdsk}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{nbi\_cxr}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Class to setup and run aurora simulations.
\index{check\_conservation() (aurora.core.aurora\_sim method)@\spxentry{check\_conservation()}\spxextra{aurora.core.aurora\_sim method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.core.aurora_sim.check_conservation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_conservation}}}{\emph{\DUrole{n}{axs}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Check particle conservation for an aurora simulation.
\begin{description}
\item[{Args}] \leavevmode{[}{]}\begin{description}
\item[{axs}] \leavevmode{[}matplotlib.Axes instances{]}
Axes to pass to \sphinxcode{\sphinxupquote{plot\_1d()}}
These may be the axes returned from a previous call to this function, to overlap 
results for different runs.

\end{description}

\item[{Returns}] \leavevmode{[}{]}\begin{description}
\item[{axs}] \leavevmode{[}matplotlib.Axes instances{]}
New or updated axes returned by \sphinxcode{\sphinxupquote{plot\_1d()}}

\end{description}

\end{description}

\end{fulllineitems}

\index{get\_aurora\_kin\_profs() (aurora.core.aurora\_sim method)@\spxentry{get\_aurora\_kin\_profs()}\spxextra{aurora.core.aurora\_sim method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.core.aurora_sim.get_aurora_kin_profs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_aurora\_kin\_profs}}}{\emph{\DUrole{n}{min\_T}\DUrole{o}{=}\DUrole{default_value}{1.01}}, \emph{\DUrole{n}{min\_ne}\DUrole{o}{=}\DUrole{default_value}{10000000000.0}}}{}
Get kinetic profiles on radial and time grids.

\end{fulllineitems}

\index{get\_par\_loss\_rate() (aurora.core.aurora\_sim method)@\spxentry{get\_par\_loss\_rate()}\spxextra{aurora.core.aurora\_sim method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.core.aurora_sim.get_par_loss_rate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_par\_loss\_rate}}}{\emph{\DUrole{n}{trust\_SOL\_Ti}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Calculate the parallel loss frequency on the radial and temporal grids {[}1/s{]}.

trust\_SOL\_Ti should generally be set to False, unless specific Ti measurements are available
in the SOL.

\end{fulllineitems}

\index{get\_time\_dept\_atomic\_rates() (aurora.core.aurora\_sim method)@\spxentry{get\_time\_dept\_atomic\_rates()}\spxextra{aurora.core.aurora\_sim method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.core.aurora_sim.get_time_dept_atomic_rates}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_time\_dept\_atomic\_rates}}}{}{}
Obtain time\sphinxhyphen{}dependent ionization and recombination rates for a simulation run.
If kinetic profiles are given as time\sphinxhyphen{}independent, atomic rates for each time slice
will be set to be the same.

\end{fulllineitems}

\index{interp\_kin\_prof() (aurora.core.aurora\_sim method)@\spxentry{interp\_kin\_prof()}\spxextra{aurora.core.aurora\_sim method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.core.aurora_sim.interp_kin_prof}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interp\_kin\_prof}}}{\emph{\DUrole{n}{prof}}}{}
Interpolate the given kinetic profile on the radial and temporal grids {[}units of s{]}.
This function extrapolates in the SOL based on input options using the same methods as in STRAHL.

\end{fulllineitems}

\index{run\_aurora() (aurora.core.aurora\_sim method)@\spxentry{run\_aurora()}\spxextra{aurora.core.aurora\_sim method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.core.aurora_sim.run_aurora}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run\_aurora}}}{\emph{\DUrole{n}{D\_z}}, \emph{\DUrole{n}{V\_z}}, \emph{\DUrole{n}{times\_DV}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{nz\_init}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}old\textquotesingle{}}}, \emph{\DUrole{n}{evolneut}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{use\_julia}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Run a simulation using inputs in the given dictionary and D,v profiles as a function
of space, time and potentially also ionization state. Users may give an initial state of each
ion charge state as an input.

Results can be conveniently visualized with time\sphinxhyphen{}slider using

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{aurora}\PYG{o}{.}\PYG{n}{slider\PYGZus{}plot}\PYG{p}{(}\PYG{n}{rhop}\PYG{p}{,}\PYG{n}{time}\PYG{p}{,} \PYG{n}{nz}\PYG{o}{.}\PYG{n}{transpose}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{rho\PYGZus{}p\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time [s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
                   \PYG{n}{zlabel}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}n\PYGZus{}z\PYGZdl{} [cm\PYGZdl{}\PYGZca{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZhy{}3\PYGZcb{}\PYGZdl{}]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{plot\PYGZus{}sum}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
                   \PYG{n}{labels}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ca\PYGZdl{}\PYGZca{}}\PYG{l+s+se}{\PYGZob{}\PYGZob{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZcb{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nz\PYGZus{}w}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{D\_z, V\_z: arrays, shape of (space, time,nZ) or (space,time) or (space,)}] \leavevmode
Diffusion and convection coefficients, in units of cm\textasciicircum{}2/s and cm/s, respectively.
This may be given as a function of (space,time) or (space,nZ, time), where nZ indicates
the number of charge states. If D\_z and V\_z are found to be have only 2 dimensions, 
it is assumed that all charge states should have the same transport coefficients.
If they are only 1\sphinxhyphen{}D, it is further assumed that they are time\sphinxhyphen{}independent. 
Note that it is assumed that D\_z and V\_z profiles are already on the self.rvol\_grid 
radial grid.

\item[{times\_DV}] \leavevmode{[}1D array, optional{]}
Array of times at which D\_z and V\_z profiles are given. By Default, this is None, 
which implies that D\_z and V\_z are time independent.

\item[{nz\_init: array, shape of (space, nZ)}] \leavevmode
Impurity charge states at the initial time of the simulation. If left to None, this is
internally set to an array of 0’s.

\item[{method}] \leavevmode{[}str, optional{]}
If method=’linder’, use the Linder algorithm for increased stability and accuracy.

\item[{evolneut}] \leavevmode{[}bool, optional{]}
If True, evolve neutral impurities based on their D,V coefficients. Default is False, in
which case neutrals are only taken as a source and those that are not ionized immediately after
injection are neglected.

\item[{use\_julia}] \leavevmode{[}bool, optional{]}
If True, run the Julia pre\sphinxhyphen{}compiled version of the code. Run the julia makefile option to set 
this up. Default is False (still under development)

\end{description}

\item[{Returns:}] \leavevmode
nz : array, 
N\_wall : array (nt,)
N\_div : array (nt,)
N\_pump : array (nt,)
N\_ret : array (nt,)
N\_tsu : array (nt,)
N\_dsu : array (nt,)
N\_dsul : array (nt,)
rcld\_rate : array (nt,)
rclw\_rate : array (nt,)

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\subsection{aurora.atomic module}
\label{\detokenize{aurora:module-aurora.atomic}}\label{\detokenize{aurora:aurora-atomic-module}}\index{module@\spxentry{module}!aurora.atomic@\spxentry{aurora.atomic}}\index{aurora.atomic@\spxentry{aurora.atomic}!module@\spxentry{module}}\index{CartesianGrid (class in aurora.atomic)@\spxentry{CartesianGrid}\spxextra{class in aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.CartesianGrid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{CartesianGrid}}}{\emph{\DUrole{n}{grids}}, \emph{\DUrole{n}{values}}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Linear multivariate Cartesian grid interpolation in arbitrary dimensions
This is a regular grid with equal spacing.

\end{fulllineitems}

\index{adas\_file (class in aurora.atomic)@\spxentry{adas\_file}\spxextra{class in aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.adas_file}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{adas\_file}}}{\emph{\DUrole{n}{filepath}}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Read ADAS file in ADF11 format over the given ne, T.
\index{load() (aurora.atomic.adas\_file method)@\spxentry{load()}\spxextra{aurora.atomic.adas\_file method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.adas_file.load}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load}}}{}{}
\end{fulllineitems}

\index{plot() (aurora.atomic.adas\_file method)@\spxentry{plot()}\spxextra{aurora.atomic.adas\_file method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.adas_file.plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot}}}{\emph{\DUrole{n}{fig}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{axes}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{adas\_files\_dict() (in module aurora.atomic)@\spxentry{adas\_files\_dict()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.adas_files_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{adas\_files\_dict}}}{}{}
Selections for ADAS files for Aurora runs and radiation calculations.
This function can be called to fetch a set of default files, which can then be modified (e.g. to 
use a new file for a specific SXR filter) before running a calculation.

\end{fulllineitems}

\index{balance() (in module aurora.atomic)@\spxentry{balance()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.balance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{balance}}}{\emph{\DUrole{n}{logTe\_val}}, \emph{\DUrole{n}{cs}}, \emph{\DUrole{n}{n0\_by\_ne}}, \emph{\DUrole{n}{logTe\_}}, \emph{\DUrole{n}{S}}, \emph{\DUrole{n}{R}}, \emph{\DUrole{n}{cx}}}{}
Evaluate balance of effective ionization, recombination and charge exchange at a given temperature.

\end{fulllineitems}

\index{get\_adas\_continuum\_rad() (in module aurora.atomic)@\spxentry{get\_adas\_continuum\_rad()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.get_adas_continuum_rad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{get\_adas\_continuum\_rad}}}{\emph{\DUrole{n}{ion\_name}}, \emph{\DUrole{n}{n\_ion}}, \emph{\DUrole{n}{logne\_prof}}, \emph{\DUrole{n}{logTe\_prof}}, \emph{\DUrole{n}{sxr}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Convenience function to get ADAS estimate for continuum radiation in {[}M/m\textasciicircum{}3{]} for a 
given background ion at given (log) density and temperature profiles.

If sxr=True, ‘prs’ files are used instead of ‘prb’ ones, thus giving SXR\sphinxhyphen{}filtered
continuum radiation for the SXR filter indicated by the atomic data dictionary.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{ion\_name}] \leavevmode{[}str{]}
Atomic symbol of ion.

\item[{n\_ion}] \leavevmode{[}array (nt,nr,nz){]}
Density of each charge state of the ion of interest

\item[{logne\_prof}] \leavevmode{[}array (nt,nr){]}
Log\sphinxhyphen{}10 of electron density profile (in cm\textasciicircum{}\sphinxhyphen{}3)

\item[{logTe\_prof}] \leavevmode{[}array (nt,nr){]}
Log\sphinxhyphen{}10 of electron temperature profile (in eV)

\item[{sxr}] \leavevmode{[}bool, optional{]}
If True, compute continuum radiation in the SXR range rather than the total 
continuum radiation.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{cont\_rad}] \leavevmode{[}array (nt,nr){]}
Continuum radiation, either total or in the SXR\sphinxhyphen{}range, depending on the 
‘sxr’ input variable.

\end{description}

\end{description}

\end{fulllineitems}

\index{get\_atom\_data() (in module aurora.atomic)@\spxentry{get\_atom\_data()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.get_atom_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{get\_atom\_data}}}{\emph{\DUrole{n}{imp}}, \emph{\DUrole{n}{files}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Collect atomic data for a given impurity from all types of ADAS files available or
for only those requested.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{imp}] \leavevmode{[}str{]}
Atomic symbol of impurity ion.

\item[{files}] \leavevmode{[}list or array\sphinxhyphen{}like{]}
ADAS file names to be fetched.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{atom\_data}] \leavevmode{[}dict{]}
Dictionary containing data for each of the requested files (or all files returned by
{\hyperref[\detokenize{aurora:aurora.atomic.adas_files_dict}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{adas\_files\_dict()}}}}} for the impurity ion of interest). 
Each entry of the dictionary gives log\sphinxhyphen{}10 of ne, log\sphinxhyphen{}10 of Te and log\sphinxhyphen{}10 of the data
as attributes atom\_data{[}key{]}.logNe, atom\_data{[}key{]}.logT, atom\_data{[}key{]}.data

\end{description}

\end{description}

\end{fulllineitems}

\index{get\_atomdat\_info() (in module aurora.atomic)@\spxentry{get\_atomdat\_info()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.get_atomdat_info}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{get\_atomdat\_info}}}{}{}
Function to identify location of ADAS atomic data in a generalized fashion
and to obtain the list of file\_types of interest.

\end{fulllineitems}

\index{get\_cooling\_factors() (in module aurora.atomic)@\spxentry{get\_cooling\_factors()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.get_cooling_factors}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{get\_cooling\_factors}}}{\emph{\DUrole{n}{atom\_data}}, \emph{\DUrole{n}{logTe\_prof}}, \emph{\DUrole{n}{fz}}, \emph{\DUrole{n}{ion\_resolved}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{plot}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{ax}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Calculate cooling coefficients for the given fractional abundances and kinetic profiles.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{atom\_data}] \leavevmode{[}dict{]}
Dictionary containing atomic data as output by {\hyperref[\detokenize{aurora:aurora.atomic.get_atom_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_atom\_data()}}}}}
for the atomic processes of interest. “prs”,”pls”,”plt” and “prb” are required by this function.

\end{description}

\end{description}

\end{fulllineitems}

\index{get\_cs\_balance\_terms() (in module aurora.atomic)@\spxentry{get\_cs\_balance\_terms()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.get_cs_balance_terms}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{get\_cs\_balance\_terms}}}{\emph{\DUrole{n}{atom\_data}}, \emph{\DUrole{n}{ne}\DUrole{o}{=}\DUrole{default_value}{5e+19}}, \emph{\DUrole{n}{Te}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{maxTe}\DUrole{o}{=}\DUrole{default_value}{10000.0}}, \emph{\DUrole{n}{include\_cx}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Get S, R and cx on the same logTe grid.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{atom\_data}] \leavevmode{[}dictionary of atomic ADAS files (only acd, scd are required; ccd is {]}
necessary only if include\_cx=True

\item[{ne}] \leavevmode{[}float or array{]}
Electron density in units of m\textasciicircum{}\sphinxhyphen{}3

\item[{Te}] \leavevmode{[}float or array{]}
Electron temperature in units of eV. If left to None, the Te grid
given in the atomic data is used.

\item[{maxTe}] \leavevmode{[}float{]}
Maximum temperature of interest; only used if Te is left to None.

\item[{include\_cx}] \leavevmode{[}bool{]}
If True, obtain charge exchange terms as well.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{logTe}] \leavevmode{[}array (n\_Te){]}
log10 Te grid on which atomic rates are given

\item[{logS, logR (,logcx): arrays (n\_ne,n\_Te)}] \leavevmode
atomic rates for effective ionization, radiative+dielectronic
recombination (+ charge exchange, if requested). After exponentiation, all terms
will be in units of s\textasciicircum{}\sphinxhyphen{}1.

\end{description}

\end{description}

\end{fulllineitems}

\index{get\_file\_types() (in module aurora.atomic)@\spxentry{get\_file\_types()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.get_file_types}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{get\_file\_types}}}{}{}
Returns main types of ADAS atomic data of interest

\end{fulllineitems}

\index{get\_frac\_abundances() (in module aurora.atomic)@\spxentry{get\_frac\_abundances()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.get_frac_abundances}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{get\_frac\_abundances}}}{\emph{\DUrole{n}{atom\_data}}, \emph{\DUrole{n}{ne}}, \emph{\DUrole{n}{Te}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{n0\_by\_ne}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}05}}, \emph{\DUrole{n}{include\_cx}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{plot}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{rho}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{rho\_lbl}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ls}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\sphinxhyphen{}\textquotesingle{}}}, \emph{\DUrole{n}{compute\_rates}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Calculate fractional abundances from ionization and recombination equilibrium.
If include\_cx=True, radiative recombination and thermal charge exchange are summed.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{atom\_data}] \leavevmode{[}dictionary of atomic ADAS files (only acd, scd are required; ccd is {]}
necessary only if include\_cx=True

\item[{ne}] \leavevmode{[}float or array{]}
Electron density in units of m\textasciicircum{}\sphinxhyphen{}3

\item[{Te}] \leavevmode{[}float or array, optional{]}
Electron temperature in units of eV. If left to None, the Te grid given in the 
atomic data is used.

\item[{n0\_by\_ne: float or array, optional}] \leavevmode
Ratio of background neutral hydrogen to electron density, used if include\_cx=True.

\item[{include\_cx}] \leavevmode{[}bool{]}
If True, charge exchange with background thermal neutrals is included.

\item[{plot}] \leavevmode{[}bool, optional{]}
Show fractional abundances as a function of ne,Te profiles parameterization.

\item[{ax}] \leavevmode{[}matplotlib.pyplot Axes instance{]}
Axes on which to plot if plot=True. If False, it creates new axes

\item[{rho}] \leavevmode{[}list or array, optional{]}
Vector of radial coordinates on which ne,Te (and possibly n0\_by\_ne) are given. 
This is only used for plotting, if given.

\item[{rho\_lbl: str, optional}] \leavevmode
Label to be used for rho. If left to None, defaults to a general “rho”.

\item[{ls}] \leavevmode{[}str, optional{]}
Line style for plots. Continuous lines are used by default.

\item[{compute\_rates}] \leavevmode{[}bool{]}
If True, compute rate coefficients for ionization/recombination equilibrium on top
of fractional abundances (which should be the same regardless of the method used).

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{logTe}] \leavevmode{[}array{]}
log10 of electron temperatures as a function of which the fractional abundances and
rate coefficients are given.

\item[{fz}] \leavevmode{[}array, (space,nZ){]}
Fractional abundances across the same grid used by the input ne,Te values.

\item[{rate\_coeff}] \leavevmode{[}array, (space, nZ){]}
Rate coefficients in units of {[}s\textasciicircum{}\sphinxhyphen{}1{]}.

\end{description}

\end{description}

\end{fulllineitems}

\index{gff\_mean() (in module aurora.atomic)@\spxentry{gff\_mean()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.gff_mean}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{gff\_mean}}}{\emph{\DUrole{n}{Z}}, \emph{\DUrole{n}{Te}}}{}
Total free\sphinxhyphen{}free gaunt factor yielding the total radiated bremsstrahlung power
when multiplying with the result for gff=1.
Data originally from Karzas \& Latter, extracted from STRAHL’s atomic\_data.f.

\end{fulllineitems}

\index{impurity\_brems() (in module aurora.atomic)@\spxentry{impurity\_brems()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.impurity_brems}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{impurity\_brems}}}{\emph{\DUrole{n}{nz}}, \emph{\DUrole{n}{ne}}, \emph{\DUrole{n}{Te}}}{}
Impurity bremsstrahlung in units of mW/nm/sr/m\textasciicircum{}3.cm\textasciicircum{}3.

This is only approximate and may not be very useful, since this contribution
is already included in the continuum in x2.

This estimate does not have the correct ne\sphinxhyphen{}dependence of the Gaunt factor… use with care!

\end{fulllineitems}

\index{interp\_atom\_prof() (in module aurora.atomic)@\spxentry{interp\_atom\_prof()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.interp_atom_prof}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{interp\_atom\_prof}}}{\emph{\DUrole{n}{atom\_table}}, \emph{\DUrole{n}{x\_prof}}, \emph{\DUrole{n}{y\_prof}}, \emph{\DUrole{n}{log\_val}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{x\_multiply}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Fast interpolate atomic data in atom\_table onto the x\_prof and y\_prof profiles.
assume that x\_prof, y\_prof, x,y, table are all decadic logarithms
and x\_prof, y\_prof are equally spaced(always for ADAS data)
log\_val bool: return natural logarithm of the data
x\_multiply bool: multiply output by 10**x\_prof , it will not not multiplied if x\_prof is None

return data interpolated on shape(nt,nion,nr)

\end{fulllineitems}

\index{main\_ion\_brems() (in module aurora.atomic)@\spxentry{main\_ion\_brems()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.main_ion_brems}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{main\_ion\_brems}}}{\emph{\DUrole{n}{Zi}}, \emph{\DUrole{n}{ni}}, \emph{\DUrole{n}{ne}}, \emph{\DUrole{n}{Te}}}{}
Main\sphinxhyphen{}ion bremsstrahlung in units of  mW/nm/sr/m\textasciicircum{}3.cm\textasciicircum{}3.

It is likely better to calculate this from H/D/T plt files, which will have more accurate 
Gaunt factors with the correct density dependence.

\end{fulllineitems}

\index{null\_space() (in module aurora.atomic)@\spxentry{null\_space()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.null_space}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{null\_space}}}{\emph{\DUrole{n}{A}}}{}
Find null space of matrix A

\end{fulllineitems}

\index{plot\_norm\_ion\_freq() (in module aurora.atomic)@\spxentry{plot\_norm\_ion\_freq()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.plot_norm_ion_freq}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{plot\_norm\_ion\_freq}}}{\emph{\DUrole{n}{S\_z}}, \emph{\DUrole{n}{q\_prof}}, \emph{\DUrole{n}{R\_prof}}, \emph{\DUrole{n}{imp\_A}}, \emph{\DUrole{n}{Ti\_prof}}, \emph{\DUrole{n}{nz\_profs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{rhop}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{eps\_prof}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Compare effective ionization rate for each charge state with the 
characteristic transit time that a non\sphinxhyphen{}trapped and trapped impurity ion takes
to travel a parallel distance L = q R.

If the normalized ionization rate is less than 1, then flux surface averaging of
background asymmetries (e.g. from edge or beam neutrals) can be considered in a 
“flux\sphinxhyphen{}surface\sphinxhyphen{}averaged” sense; otherwise, local effects (i.e. not flux\sphinxhyphen{}surface\sphinxhyphen{}averaged)
may be too important to ignore.

This function is inspired by Dux et al. NF 2020. Note that in this paper the ionization 
rate averaged over all charge state densities is considered. This function avoids the 
averaging over charge states, unless these are provided as an input.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{S\_z}] \leavevmode{[}array (r,cs) {[}s\textasciicircum{}\sphinxhyphen{}1{]}{]}
Effective ionization rates for each charge state as a function of radius. 
Note that, for convenience within aurora, cs includes the neutral stage.

\item[{q\_prof}] \leavevmode{[}array (r,){]}
Radial profile of safety factor

\item[{R\_prof}] \leavevmode{[}array (r,) or float {[}m{]}{]}
Radial profile of major radius, either given as an average of HFS and LFS, or also
simply as a scalar (major radius on axis)

\item[{imp\_A}] \leavevmode{[}float {[}amu{]}{]}
Atomic mass number, i.e. number of protons + neutrons (e.g. 2 for D)

\item[{Ti\_prof}] \leavevmode{[}array (r,){]}
Radial profile of ion temperature {[}eV{]}

\item[{nz\_profs}] \leavevmode{[}array (r,cs), optional{]}
Radial profile for each charge state. If provided, calculate average normalized 
ionization rate over all charge states.

\item[{rhop}] \leavevmode{[}array (r,), optional{]}
Sqrt of poloidal flux radial grid. This is used only for (optional) plotting.

\item[{plot}] \leavevmode{[}bool, optional{]}
If True, plot results.

\item[{eps\_prof}] \leavevmode{[}array (r,), optional{]}
Radial profile of inverse aspect ratio, i.e. r/R, only used if plotting is requested.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{nu\_ioniz\_star}] \leavevmode{[}array (r,cs) or (r,){]}
Normalized ionization rate. If nz\_profs is given as an input, this is an average over
all charge state; otherwise, it is given for each charge state.

\end{description}

\end{description}

\end{fulllineitems}

\index{plot\_relax\_time() (in module aurora.atomic)@\spxentry{plot\_relax\_time()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.plot_relax_time}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{plot\_relax\_time}}}{\emph{\DUrole{n}{logTe}}, \emph{\DUrole{n}{rate\_coeff}}, \emph{\DUrole{n}{ne\_mean}}, \emph{\DUrole{n}{ax}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Plot relaxation time of the ionization equilibrium corresponding
to the inverse of the given rate coefficients

\end{fulllineitems}

\index{read\_adf15() (in module aurora.atomic)@\spxentry{read\_adf15()}\spxextra{in module aurora.atomic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.atomic.read_adf15}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.atomic.}}\sphinxbfcode{\sphinxupquote{read\_adf15}}}{\emph{\DUrole{n}{path}}, \emph{\DUrole{n}{order}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{Te\_max}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ne\_max}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot\_log}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{plot\_3d}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{recomb}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{pec\_plot\_min}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{pec\_plot\_max}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot\_lines}\DUrole{o}{=}\DUrole{default_value}{{[}{]}}}}{}
Read photon emissivity coefficients from an ADF15 file.

Returns a dictionary whose keys are the wavelengths of the lines in
angstroms. The value is an interp2d instance that will evaluate the PEC at
a desired dens, temp.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{path}] \leavevmode{[}str{]}
Path to adf15 file to read.

\item[{order}] \leavevmode{[}int, opt{]}
Parameter to control the order of interpolation.

\item[{recomb}] \leavevmode{[}bool, opt{]}
If True, fetch recombination contributions to available lines. If False,
fetch only ionization contributions.

\end{description}

To plot PEC data:
\begin{description}
\item[{plot\_lines}] \leavevmode{[}list{]}
List of lines whose PEC data should be displayed. Lines should be identified
by their wavelengths. The list of available wavelengths in a given file can be retrieved
by first running this function ones, checking dictionary keys, and then requesting a
plot of one (or more) of them.

\item[{plot\_log}] \leavevmode{[}bool{]}
When plotting, set a log scale

\item[{plot\_3d}] \leavevmode{[}bool{]}
Display PEC data as a 3D plot rather than a 2D one.

\item[{pec\_plot\_min}] \leavevmode{[}float{]}
Minimum value of PEC to visualize in a plot

\item[{pec\_plot\_max}] \leavevmode{[}float{]}
Maximum value of PEC to visualize in a plot

\item[{ax}] \leavevmode{[}matplotlib axes instance{]}
If not None, plot on this set of axes

\item[{Te\_max}] \leavevmode{[}float{]}
Maximum Te value to plot when len(plot\_lines)\textgreater{}1

\item[{ne\_max}] \leavevmode{[}float{]}
Maximum ne value to plot when len(plot\_lines)\textgreater{}1

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{pec\_dict}] \leavevmode{[}dict{]}
Dictionary containing interpolation functions for each of the available lines of the
indicated type (ionization or recombination). Each interpolation function takes as arguments
the log\sphinxhyphen{}10 of ne and Te.

\end{description}

\item[{MWE:}] \leavevmode
path=’/home/sciortino/atomlib/atomdat\_master/adf15/h/pju\#h0.dat’
pec = read\_adf15(path, recomb=False)
pec = read\_adf15(path, plot\_lines={[}list(pec.keys()){[}0{]}{]}, recomb=False)

\end{description}

This function should work with PEC files produced via adas810 or adas218.

\end{fulllineitems}



\subsection{aurora.radiation module}
\label{\detokenize{aurora:module-aurora.radiation}}\label{\detokenize{aurora:aurora-radiation-module}}\index{module@\spxentry{module}!aurora.radiation@\spxentry{aurora.radiation}}\index{aurora.radiation@\spxentry{aurora.radiation}!module@\spxentry{module}}\index{adf04\_files() (in module aurora.radiation)@\spxentry{adf04\_files()}\spxextra{in module aurora.radiation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.radiation.adf04_files}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.radiation.}}\sphinxbfcode{\sphinxupquote{adf04\_files}}}{}{}
Collection of trust\sphinxhyphen{}worthy ADAS ADF04 files. 
This function will be moved and expanded in ColRadPy in the near future.

\end{fulllineitems}

\index{compute\_rad() (in module aurora.radiation)@\spxentry{compute\_rad()}\spxextra{in module aurora.radiation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.radiation.compute_rad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.radiation.}}\sphinxbfcode{\sphinxupquote{compute\_rad}}}{\emph{\DUrole{n}{imp}}, \emph{\DUrole{n}{rhop}}, \emph{\DUrole{n}{time}}, \emph{\DUrole{n}{imp\_dens}}, \emph{\DUrole{n}{ne}}, \emph{\DUrole{n}{Te}}, \emph{\DUrole{n}{n0}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{nD}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{main\_ion\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}D\textquotesingle{}}}, \emph{\DUrole{n}{sxr\_pls\_file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{sxr\_prs\_file}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{prad\_flag}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{thermal\_cx\_rad\_flag}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{spectral\_brem\_flag}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sxr\_flag}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{main\_ion\_brem\_flag}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Calculate radiation terms corresponding to a simulation result. 
Results are in SI units (NB: inputs are not).

Result can be conveniently plotted with a time\sphinxhyphen{}slider using, for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{zmax} \PYG{o}{=} \PYG{n}{imp\PYGZus{}dens}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} number of charge states (including neutrals)}
\PYG{n}{rad} \PYG{o}{=} \PYG{n}{res}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{impurity\PYGZus{}radiation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{n}{zmax}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}   \PYG{c+c1}{\PYGZsh{} no fully\PYGZhy{}stripped line radiation}
\PYG{n}{aurora}\PYG{o}{.}\PYG{n}{slider\PYGZus{}plot}\PYG{p}{(}\PYG{n}{rhop}\PYG{p}{,}\PYG{n}{time}\PYG{p}{,} \PYG{n}{rad}\PYG{o}{.}\PYG{n}{transpose}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{1e6}\PYG{p}{,}
    \PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{rho\PYGZus{}p\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time [s]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
    \PYG{n}{zlabel}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}P\PYGZus{}}\PYG{l+s+si}{\PYGZob{}rad\PYGZcb{}}\PYG{l+s+s1}{\PYGZdl{} [\PYGZdl{}MW\PYGZdl{}]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{plot\PYGZus{}sum}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
    \PYG{n}{labels}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ca\PYGZdl{}\PYGZca{}}\PYG{l+s+se}{\PYGZob{}\PYGZob{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZcb{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nz\PYGZus{}w}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Note that, when sxr\_flag=True, SXR radiation will be computed using the default ADAS ‘pls’ and ‘prs’ files
(line and continuum radiation) given by the atomic.adas\_files\_dict() unless the sxr\_pls\_file and sxr\_prs\_file
parameters are provided.

All radiation outputs are given in \(W cm^-3\), consistently with units of \(cm^-3\) given for inputs.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{imp}] \leavevmode{[}str{]}
Impurity symbol, e.g. Ca, F, W

\item[{rhop}] \leavevmode{[}array (space,){]}
Sqrt of poloidal flux radial grid of simulation output.

\item[{time}] \leavevmode{[}array (time,){]}
Time array of simulation output.

\item[{imp\_dens}] \leavevmode{[}array (time, nZ, space){]}
Dictionary with impurity density result, as given by \sphinxcode{\sphinxupquote{run\_aurora()}} method.

\item[{ne}] \leavevmode{[}array (time,space) {[}cm\textasciicircum{}\sphinxhyphen{}3{]}{]}
Electron density on the output grids.

\item[{Te}] \leavevmode{[}array (time,space) {[}eV{]}{]}
Electron temperature on the output grids.

\item[{n0}] \leavevmode{[}array(time,space), optional {[}cm\textasciicircum{}\sphinxhyphen{}3{]}{]}
Background neutral density (assumed of hydrogen\sphinxhyphen{}isotopes). 
This is only used if thermal\_cx\_rad\_flag=True.

\item[{nD}] \leavevmode{[}array (time,space), optional {[}cm\textasciicircum{}\sphinxhyphen{}3{]}{]}
Main ion density. This is only used if main\_ion\_brem\_flag=True.

\item[{main\_ion\_name}] \leavevmode{[}str, optional{]}
Atomic symbol of main ion species. Default is ‘D’.
This is only used if main\_ion\_brem\_flag=True.

\item[{sxr\_pls\_file}] \leavevmode{[}str{]}
ADAS file used for SXR line radiation calculation if sxr\_flag=True. If left to None, the 
default in {\hyperref[\detokenize{aurora:aurora.atomic.adas_files_dict}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{adas\_files\_dict()}}}}} is used.

\item[{sxr\_prs\_file}] \leavevmode{[}str{]}
ADAS file used for SXR continuum radiation calculation if sxr\_flag=True. If left to None, 
the default in {\hyperref[\detokenize{aurora:aurora.atomic.adas_files_dict}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{adas\_files\_dict()}}}}} is used.

\item[{prad\_flag}] \leavevmode{[}bool, optional{]}
If True, total radiation is computed (for each charge state and their sum)

\item[{thermal\_cx\_rad\_flag}] \leavevmode{[}bool, optional{]}
If True, thermal charge exchange radiation is computed.

\item[{spectral\_brem\_flag}] \leavevmode{[}bool, optional{]}
If True, spectral bremstrahlung is computed (based on available ‘brs’ ADAS file)

\item[{sxr\_flag}] \leavevmode{[}bool, optional{]}
If True, soft x\sphinxhyphen{}ray radiation is computed (for the given ‘pls’,’prs’ ADAS files)

\item[{main\_ion\_brem\_flag}] \leavevmode{[}bool, optional{]}
If True, main ion bremstrahlung (all contributions) is computed.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{res}] \leavevmode{[}dict{]}
Dictionary containing the radiation terms, depending on the activated flags.
The structure of this output is intentionally left to be the same as in STRAHL
for convenience.

If all flags were on, the dictionary would include
\{‘impurity\_radiation’,’spectral\_bremsstrahlung’,’sxr\_radiation’\}

Impurity\_radiation and sxr\_radiation:
index 0: total line radiation of neutral impurity
index 1: total line radiation of singly ionised impurity
….
index n\sphinxhyphen{}1: total line radiation of hydrogen\sphinxhyphen{}like ion
index n: bremsstrahlung due to electron scattering at main ion (if requested)
index n+1: total continuum radiation of impurity (bremsstrahlung and recombination continua)
index n+2: bremsstrahlung due to electron scattering at impurity
index n+3: total radiation of impurity (and main ion, if set in Xx.atomdat)

Spectral\_bremsstrahlung:
index 0: = 0
index 1: bremsstrahlung due to electron scattering at singly ionised impurity
….
index n: bremsstrahlung due to electron scattering at fully ionised impurity
index n+1: bremsstrahlung due to electron scattering at main ion
index n+2: total bremsstrahlung of impurity (and main ion, if set in Xx.atomdat)

\end{description}

\end{description}

\end{fulllineitems}

\index{get\_pec\_prof() (in module aurora.radiation)@\spxentry{get\_pec\_prof()}\spxextra{in module aurora.radiation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.radiation.get_pec_prof}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.radiation.}}\sphinxbfcode{\sphinxupquote{get\_pec\_prof}}}{\emph{\DUrole{n}{ion}}, \emph{\DUrole{n}{cs}}, \emph{\DUrole{n}{rhop}}, \emph{\DUrole{n}{ne\_cm3}}, \emph{\DUrole{n}{Te\_eV}}, \emph{\DUrole{n}{lam\_nm}\DUrole{o}{=}\DUrole{default_value}{1.8705}}, \emph{\DUrole{n}{lam\_width\_nm}\DUrole{o}{=}\DUrole{default_value}{0.002}}, \emph{\DUrole{n}{meta\_idxs}\DUrole{o}{=}\DUrole{default_value}{{[}0{]}}}, \emph{\DUrole{n}{adf04\_repo}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}/home/sciortino/adf04\_files/ca/ca\_adf04\_adas/\textquotesingle{}}}, \emph{\DUrole{n}{pec\_threshold}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}20}}, \emph{\DUrole{n}{phot2energy}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{plot}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Compute radial profile for Photon Emissivity Coefficients (PEC) for lines within the chosen
wavelength range using the ColRadPy package. This is an alternative to the option of using 
the :py:method:atomic.read\_adf15() function to read PEC data from an ADAS ADF\sphinxhyphen{}15 file and 
interpolate results on ne,Te grids.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{ion}] \leavevmode{[}str{]}
Ion atomic symbol

\item[{cs}] \leavevmode{[}str{]}
Charge state, given in format like ‘Ca18+’

\item[{rhop}] \leavevmode{[}array (nr,){]}
Srt of normalized poloidal flux radial array

\item[{ne\_cm3}] \leavevmode{[}array (nr,){]}
Electron density in cm\textasciicircum{}\sphinxhyphen{}3 units

\item[{Te\_eV}] \leavevmode{[}array (nr,){]}
Electron temperature in eV units

\item[{lam\_nm}] \leavevmode{[}float{]}
Center of the wavelength region of interest {[}nm{]}

\item[{lam\_width\_nm}] \leavevmode{[}float{]}
Width of the wavelength region of interest {[}nm{]}

\item[{meta\_idxs}] \leavevmode{[}list of integers{]}
List of levels in ADF04 file to be treated as metastable states.

\item[{adf04\_repo}] \leavevmode{[}str{]}
Location where ADF04 file from :py:method:adf04\_files() should be fetched.

\item[{prec\_threshold}] \leavevmode{[}float{]}
Minimum value of PECs to be considered, in photons.cm\textasciicircum{}3/s

\item[{phot2energy}] \leavevmode{[}bool{]}
If True, results are converted from photons.cm\textasciicircum{}3/s to W.cm\textasciicircum{}3

\item[{plot}] \leavevmode{[}bool{]}
If True, plot lines profiles and total

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{pec\_tot\_prof}] \leavevmode{[}array (nr,){]}
Radial profile of PEC intensity, in units of \(photons cm^3/s\) (if phot2energy=False) or 
\(W \cdot cm^3\) depending (if phot2energy=True).

\end{description}

\end{description}

\end{fulllineitems}

\index{plot\_radiation\_profs() (in module aurora.radiation)@\spxentry{plot\_radiation\_profs()}\spxextra{in module aurora.radiation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.radiation.plot_radiation_profs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.radiation.}}\sphinxbfcode{\sphinxupquote{plot\_radiation\_profs}}}{\emph{\DUrole{n}{imp}}, \emph{\DUrole{n}{nz\_prof}}, \emph{\DUrole{n}{logne\_prof}}, \emph{\DUrole{n}{logTe\_prof}}, \emph{\DUrole{n}{xvar\_prof}}, \emph{\DUrole{n}{xvar\_label}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{atom\_data}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Compute profiles of predicted radiation, both SXR\sphinxhyphen{}filtered and unfiltered.
This function offers a simplified interface to radiation calculation with respect to 
{\hyperref[\detokenize{aurora:aurora.radiation.compute_rad}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{compute\_rad()}}}}}, which is more complete.

This function can be used to plot radial profiles (setting xvar\_prof to a radial grid)
or profiles as a function of any variable on which the logne\_prof and logTe\_prof
may depend.

The variable “nz\_prof” may be a full description of impurity charge state densities
(e.g. the output of aurora), or profiles of fractional abundances from ionization equilibrium.
\begin{description}
\item[{Args: }] \leavevmode\begin{description}
\item[{imp}] \leavevmode{[}str, optional{]}
Impurity ion atomic symbol.

\item[{nz\_prof}] \leavevmode{[}array (TODO for docs: check dimensions){]}
Impurity charge state densities

\item[{logne\_prof}] \leavevmode{[}array (TODO for docs: check dimensions){]}
Electron density profiles in cm\textasciicircum{}\sphinxhyphen{}3

\item[{logTe\_prof}] \leavevmode{[}array (TODO for docs: check dimensions){]}
Electron temperature profiles in eV

\item[{xvar\_prof}] \leavevmode{[}array (TODO for docs: check dimensions){]}
Profiles of a variable of interest, on the same grid as kinetic profiles.

\item[{xvar\_label}] \leavevmode{[}str, optional{]}
Label for x\sphinxhyphen{}axis.

\item[{atom\_data}] \leavevmode{[}dict, optional{]}
Dictionary containing atomic data as output by {\hyperref[\detokenize{aurora:aurora.atomic.get_atom_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_atom\_data()}}}}}
for the atomic processes of interest. “prs”,”pls”,”plt” and “prb” are required by this function.
If not provided, this function loads these files internally.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{pls}] \leavevmode{[}array (TODO for docs: check dimensions){]}
SXR line radiation.

\item[{prs}] \leavevmode{[}array (TODO for docs: check dimensions){]}
SXR continuum radiation.

\item[{pltt}] \leavevmode{[}array (TODO for docs: check dimensions){]}
Unfiltered line radiation.

\item[{prb}] \leavevmode{[}array (TODO for docs: check dimensions){]}
Unfiltered continuum radiation.

\end{description}

\end{description}

\end{fulllineitems}

\index{radiation\_model() (in module aurora.radiation)@\spxentry{radiation\_model()}\spxextra{in module aurora.radiation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.radiation.radiation_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.radiation.}}\sphinxbfcode{\sphinxupquote{radiation\_model}}}{\emph{\DUrole{n}{imp}}, \emph{\DUrole{n}{rhop}}, \emph{\DUrole{n}{ne\_cm3}}, \emph{\DUrole{n}{Te\_eV}}, \emph{\DUrole{n}{vol}}, \emph{\DUrole{n}{n0\_cm3}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{nz\_cm3}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{frac}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Model radiation from a fixed\sphinxhyphen{}impurity\sphinxhyphen{}fraction model or from detailed impurity density
profiles for the chosen ion. This method acts as a wrapper for :py:method:compute\_rad(), 
calculating radiation terms over the radius and integrated over the plasma cross section.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{imp}] \leavevmode{[}str (nr,){]}
Impurity ion symbol, e.g. W

\item[{rhop}] \leavevmode{[}array (nr,){]}
Sqrt of normalized poloidal flux array from the axis outwards

\item[{ne\_cm3}] \leavevmode{[}array (nr,){]}
Electron density in \(cm^-3\) units.

\item[{Te\_eV}] \leavevmode{[}array (nr,){]}
Electron temperature in eV

\item[{vol}] \leavevmode{[}array (nr,){]}
Volume of each flux surface in \(m^3\).

\item[{n0\_cm3}] \leavevmode{[}array (nr,), optional{]}
Background ion density (H,D or T). If provided, charge exchange (CX) 
recombination is included in the calculation of charge state fractional 
abundances.

\item[{nz\_cm3}] \leavevmode{[}array (nr,nz), optional{]}
Impurity charge state densities in cm\textasciicircum{}\sphinxhyphen{}3 units. Fractional abundancies can 
alternatively be specified via the :param:frac parameter for a constant\sphinxhyphen{}fraction
impurity model across the radius. If provided, nz\_cm3 is used.

\item[{frac}] \leavevmode{[}float, optional{]}
Fractional abundance, with respect to ne, of the chosen impurity. 
The same fraction is assumed across the radial profile. If left to None,
nz\_cm3 must be given.

\item[{plot}] \leavevmode{[}bool, optional{]}
If True, plot a number of diagnostic figures.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{res}] \leavevmode{[}dict{]}
Dictionary containing results of radiation model.

\end{description}

\end{description}

\end{fulllineitems}



\subsection{aurora.grids\_utils module}
\label{\detokenize{aurora:module-aurora.grids_utils}}\label{\detokenize{aurora:aurora-grids-utils-module}}\index{module@\spxentry{module}!aurora.grids\_utils@\spxentry{aurora.grids\_utils}}\index{aurora.grids\_utils@\spxentry{aurora.grids\_utils}!module@\spxentry{module}}
Methods to create radial and time grids for aurora simulations.
\index{create\_aurora\_time\_grid() (in module aurora.grids\_utils)@\spxentry{create\_aurora\_time\_grid()}\spxextra{in module aurora.grids\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.grids_utils.create_aurora_time_grid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.grids\_utils.}}\sphinxbfcode{\sphinxupquote{create\_aurora\_time\_grid}}}{\emph{\DUrole{n}{timing}}, \emph{\DUrole{n}{plot}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Create time grid for simulations using a Fortran routine for definitions. 
The same functionality is offered by \sphinxcode{\sphinxupquote{create\_time\_grid()}}, which however
is written in Python. This method is legacy code; it is recommended to use the other.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{timing}] \leavevmode{[}dict{]}
Dictionary containing 
timing{[}‘times’{]},timing{[}‘dt\_start’{]},timing{[}‘steps\_per\_cycle’{]},timing{[}‘dt\_increase’{]}
which define the start times to change dt values at, the dt values to start with,
the number of time steps before increasing the dt by dt\_increase. 
The last value in each of these arrays is used for sawteeth, whenever these are
modelled, or else are ignored. This is the same time grid definition as used in STRAHL.

\item[{plot}] \leavevmode{[}bool, optional{]}
If True, display the created time grid.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{time}] \leavevmode{[}array{]}
Computational time grid corresponding to \sphinxtitleref{timing} input.

\item[{save}] \leavevmode{[}array{]}
Array of zeros and ones, where ones indicate that the time step will be stored in memory
in aurora simulations. Points corresponding to zeros will not be returned to spare memory.

\end{description}

\end{description}

\end{fulllineitems}

\index{create\_radial\_grid() (in module aurora.grids\_utils)@\spxentry{create\_radial\_grid()}\spxextra{in module aurora.grids\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.grids_utils.create_radial_grid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.grids\_utils.}}\sphinxbfcode{\sphinxupquote{create\_radial\_grid}}}{\emph{\DUrole{n}{namelist}}, \emph{\DUrole{n}{plot}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Create radial grid for aurora based on K, dr\_0, dr\_1, rvol\_lcfs and bound\_sep parameters. 
The lim\_sep parameters is additionally used if plotting is requested.

Radial mesh points are set to be equidistant in the coordinate \(\rho\), with
\begin{equation*}
\begin{split}\rho = \frac{r}{\Delta r_{centre}} + \frac{r_{edge}}{k+1} \left(\frac{1}{\Delta r_{edge}}- \frac{1}{\Delta r_{centre}} \right) \left(\frac{r}{r_{edge}} \right)^{k+1}\end{split}
\end{equation*}
The corresponding radial step size is
\begin{equation*}
\begin{split}\Delta r = \left[\frac{1}{\Delta r_{centre}} + \left(\frac{1}{\Delta r_{edge}} - \frac{1}{\Delta r_{centre}} \right) \left(\frac{r}{r_{edge}}\right)^k \right]^{-1}\end{split}
\end{equation*}
See the STRAHL manual for details.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{namelist}] \leavevmode{[}dict{]}
Dictionary containing aurora namelist. This function uses the K, dr\_0, dr\_1, rvol\_lcfs 
and bound\_sep parameters. Additionally, lim\_sep is used if plotting is requested.

\item[{plot}] \leavevmode{[}bool, optional{]}
If True, plot the radial grid spacing vs. radial location.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{rvol\_grid}] \leavevmode{[}array{]}
Volume\sphinxhyphen{}normalized grid used for aurora simulations.

\item[{pro}] \leavevmode{[}array{]}
Normalized first derivatives of the radial grid, defined as 
pro = (drho/dr)/(2 d\_rho) = rho’/(2 d\_rho)

\item[{qpr}] \leavevmode{[}array{]}
Normalized second derivatives of the radial grid, defined as 
qpr = (d\textasciicircum{}2 rho/dr\textasciicircum{}2)/(2 d\_rho) = rho’’/(2 d\_rho)

\item[{prox\_param}] \leavevmode{[}float{]}
Grid parameter used for perpendicular loss rate at the last radial grid point.

\end{description}

\end{description}

\end{fulllineitems}

\index{create\_time\_grid() (in module aurora.grids\_utils)@\spxentry{create\_time\_grid()}\spxextra{in module aurora.grids\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.grids_utils.create_time_grid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.grids\_utils.}}\sphinxbfcode{\sphinxupquote{create\_time\_grid}}}{\emph{\DUrole{n}{timing}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Create time grid for simulations using the Fortran implementation
of the time grid generator.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{timing}] \leavevmode{[}dict{]}
Dictionary containing timing elements: ‘times’, ‘dt\_start’, ‘steps\_per\_cycle’,’dt\_increase’
As in STRAHL, the last element in each of these arrays refers to sawtooth events.

\item[{plot}] \leavevmode{[}bool{]}
If True, plot time grid.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{time}] \leavevmode{[}array{]}
Computational time grid corresponding to :param:timing input.

\item[{save}] \leavevmode{[}array{]}
Array of zeros and ones, where ones indicate that the time step will be stored in memory
in aurora simulations. Points corresponding to zeros will not be returned to spare memory.

\end{description}

\end{description}

\end{fulllineitems}

\index{create\_time\_grid\_new() (in module aurora.grids\_utils)@\spxentry{create\_time\_grid\_new()}\spxextra{in module aurora.grids\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.grids_utils.create_time_grid_new}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.grids\_utils.}}\sphinxbfcode{\sphinxupquote{create\_time\_grid\_new}}}{\emph{\DUrole{n}{timing}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{plot}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Define time base for Aurora based on user inputs
This function reproduces the functionality of STRAHL’s time\_steps.f
Refer to the STRAHL manual for definitions of the time grid
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{n}] \leavevmode{[}int{]}
Number of elements in time definition arrays

\item[{t}] \leavevmode{[}array{]}
Time vector of the time base changes

\item[{dtstart}] \leavevmode{[}array{]}
dt value at the start of a cycle

\item[{itz}] \leavevmode{[}array{]}
cycle length, i.e. number of time steps before increasing dt

\item[{tinc :}] \leavevmode
factor by which time steps should be increasing within a cycle

\item[{verbose}] \leavevmode{[}bool{]}
If Trueprint to terminal a few extra info

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{t\_vals}] \leavevmode{[}array{]}
Times in the time base {[}s{]}

\item[{i\_save}] \leavevmode{[}array{]}
Array of 0,1 values indicating at which times internal arrays should be stored/returned.

\end{description}

\end{description}

\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{} THIS ISN’T FUNCTIONAL YET! \textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}

\end{fulllineitems}

\index{get\_HFS\_LFS() (in module aurora.grids\_utils)@\spxentry{get\_HFS\_LFS()}\spxextra{in module aurora.grids\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.grids_utils.get_HFS_LFS}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.grids\_utils.}}\sphinxbfcode{\sphinxupquote{get\_HFS\_LFS}}}{\emph{\DUrole{n}{geqdsk}}, \emph{\DUrole{n}{rho\_pol}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get high\sphinxhyphen{}field\sphinxhyphen{}side (HFS) and low\sphinxhyphen{}field\sphinxhyphen{}side (LFS) major radii from the g\sphinxhyphen{}EQDSK data. 
This is useful to define the r\_V grid outside of the LCFS. 
See the \sphinxcode{\sphinxupquote{get\_rhopol\_rV\_mapping()}} for an application.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{geqdsk}] \leavevmode{[}dict{]}
Dictionary containing the g\sphinxhyphen{}EQDSK file as processed by the \sphinxstyleemphasis{omfit\_eqdsk}
package.

\item[{rho\_pol}] \leavevmode{[}array, optional{]}
Array corresponding to a grid in sqrt of normalized poloidal flux for which a 
corresponding r\_V grid should be found. If left to None, an arbitrary grid will be 
created internally.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{Rhfs}] \leavevmode{[}array{]}
Major radius {[}m{]} on the HFS

\item[{Rlfs}] \leavevmode{[}array{]}
Major radius {[}m{]} on the LFS

\end{description}

\end{description}

\end{fulllineitems}

\index{get\_rhopol\_rV\_mapping() (in module aurora.grids\_utils)@\spxentry{get\_rhopol\_rV\_mapping()}\spxextra{in module aurora.grids\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.grids_utils.get_rhopol_rV_mapping}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.grids\_utils.}}\sphinxbfcode{\sphinxupquote{get\_rhopol\_rV\_mapping}}}{\emph{\DUrole{n}{geqdsk}}, \emph{\DUrole{n}{rho\_pol}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Compute arrays allowing 1\sphinxhyphen{}to\sphinxhyphen{}1 mapping of rho\_pol and r\_V, both inside and
outside the LCFS.

r\_V is defined as \(\sqrt{V/(2 \pi^2 R_{axis}}\) inside the LCFS. Outside of it,
we artificially expand the LCFS to fit true equilibrium at the midplane based
on the rho\_pol grid (sqrt of normalized poloidal flux).

Method:
\begin{equation*}
\begin{split}r(\rho,\theta) = r_0(\rho) +  (r_{lcfs}(\theta) - r_{0,lcfs}) \times \mathcal{f} \\
z(\rho,\theta) = z_0      +  (z_{lcfs}(\theta) - z_0     ) \times \mathcal{f} \\
\mathcal{f} = \frac{ r(\rho,\theta=0) - r(\rho,\theta=180)}{r_{lcfs}(\theta=0)- r_{lcfs}(\theta=180)} \\
r_{0,lcfs} = \frac{1}{2} (r_{lcfs}(\theta=0)+ r_{lcfs}(\theta=180)) \\
r_0(\rho) = \frac{1}{2} (r(\rho,\theta=0) + r(\rho,\theta=180))\end{split}
\end{equation*}
The mapping between rho\_pol and r\_V allows one to interpolate inputs on a
rho\_pol grid onto the r\_V grid (in cm) used internally by the code.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{geqdsk}] \leavevmode{[}dict{]}
Dictionary containing the g\sphinxhyphen{}EQDSK file as processed by the \sphinxstyleemphasis{omfit\_eqdsk}
package.

\item[{rho\_pol}] \leavevmode{[}array, optional{]}
Array corresponding to a grid in sqrt of normalized poloidal flux for which a 
corresponding r\_V grid should be found. If left to None, an arbitrary grid will be 
created internally.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{rho\_pol}] \leavevmode{[}array{]}
Sqrt of normalized poloidal flux grid

\item[{r\_V}] \leavevmode{[}array{]}
Mapping of rho\_pol to a radial grid defined in terms of normalized flux surface volume.

\end{description}

\end{description}

\end{fulllineitems}



\subsection{aurora.coords module}
\label{\detokenize{aurora:module-aurora.coords}}\label{\detokenize{aurora:aurora-coords-module}}\index{module@\spxentry{module}!aurora.coords@\spxentry{aurora.coords}}\index{aurora.coords@\spxentry{aurora.coords}!module@\spxentry{module}}\index{rV\_vol\_average() (in module aurora.coords)@\spxentry{rV\_vol\_average()}\spxextra{in module aurora.coords}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.coords.rV_vol_average}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.coords.}}\sphinxbfcode{\sphinxupquote{rV\_vol\_average}}}{\emph{\DUrole{n}{quant}}, \emph{\DUrole{n}{r\_V}}}{}~\begin{description}
\item[{Calculate a volume average of the given radially\sphinxhyphen{}dependent quantity on a r\_V grid.}] \leavevmode
This function makes useof the fact that the r\_V radial coordinate, defined as 
r\_V = sqrt\{ V / (2 pi\textasciicircum{}2 R\_\{axis\} \},
maps shaped volumes onto a circular geometry, making volume averaging a trivial 
operation via
langle Q

\item[{angle = Sigma\_i Q(r\_i) 2 pi Delta r\_V}] \leavevmode
where \$Delta r\_V\$ is the spacing between radial points in r\_V.

Note that if the input r\_V coordinate is extended outside the LCFS,
this function will return the effective volume average also in the SOL, since it is 
agnostic to the presence of the LCFS.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{quant}] \leavevmode{[}array, (space, …){]}
quantity that one wishes to volume\sphinxhyphen{}average. The first dimension must correspond to r\_V,
but other dimensions may be exist afterwards.

\item[{r\_V}] \leavevmode{[}array, (space,){]}
Radial r\_V coordinate in cm units.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{quant\_vol\_avg}] \leavevmode{[}array, (space, …){]}
Volume average of the quantity given as an input, in the same units as in the input

\end{description}

\end{description}

\end{description}

\end{fulllineitems}

\index{rad\_coord\_transform() (in module aurora.coords)@\spxentry{rad\_coord\_transform()}\spxextra{in module aurora.coords}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.coords.rad_coord_transform}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.coords.}}\sphinxbfcode{\sphinxupquote{rad\_coord\_transform}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{name\_in}}, \emph{\DUrole{n}{name\_out}}, \emph{\DUrole{n}{geqdsk}}}{}
Transform from one radial coordinate to another.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{x: array}] \leavevmode
input x coordinate

\item[{name\_in: str}] \leavevmode
input x coordinate name (‘rhon’,’r\_V’,’rhop’,’rhov’,’Rmid’,’rmid’,’roa’)

\item[{name\_out: str}] \leavevmode
input x coordinate (‘rhon’, ‘r\_V’, ‘rhop’,’rhov’,’Rmid’,’rmid’,’roa’)

\item[{geqdsk: dict}] \leavevmode
gEQDSK dictionary, as obtained from the omfit\sphinxhyphen{}eqdsk package.

\end{description}

\item[{Returns:}] \leavevmode
Conversion of \sphinxtitleref{x} for the requested radial grid coordinate.

\end{description}

\end{fulllineitems}

\index{vol\_average() (in module aurora.coords)@\spxentry{vol\_average()}\spxextra{in module aurora.coords}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.coords.vol_average}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.coords.}}\sphinxbfcode{\sphinxupquote{vol\_average}}}{\emph{\DUrole{n}{quant}}, \emph{\DUrole{n}{rhop}}, \emph{\DUrole{n}{method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}omfit\textquotesingle{}}}, \emph{\DUrole{n}{geqdsk}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{device}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{shot}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{time}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{return\_geqdsk}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Calculate the volume average of the given radially\sphinxhyphen{}dependent quantity on a rhop grid.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{quant}] \leavevmode{[}array, (space, …){]}
quantity that one wishes to volume\sphinxhyphen{}average. The first dimension must correspond to space,
but other dimensions may be exist afterwards.

\item[{rhop}] \leavevmode{[}array, (space,){]}
Radial rhop coordinate in cm units.

\item[{method}] \leavevmode{[}\{‘omfit’,’fs’\}{]}
Method to evaluate the volume average. The two options correspond to the way to compute
volume averages via the OMFIT fluxSurfaces classes and via a simpler cumulative sum in r\_V 
coordinates. The methods only slightly differ in their results. Note that ‘omfit’ will fail if 
rhop extends beyond the LCFS, while method ‘fs’ can estimate volume averages also into the SOL.
Default is method=’omfit’.

\item[{geqdsk}] \leavevmode{[}output of the omfit\_eqdsk.OMFITgeqdsk class, postprocessing the EFIT geqdsk file{]}
containing the magnetic geometry. If this is left to None, the function internally tries to fetch
it using MDS+ and omfit\_eqdsk. In this case, device, shot and time to fetch the equilibrium 
are required.

\item[{device}] \leavevmode{[}str{]}
Device name. Note that routines for this device must be implemented in omfit\_eqdsk for this 
to work.

\item[{shot}] \leavevmode{[}int{]}
Shot number of the above device, e.g. 1101014019 for C\sphinxhyphen{}Mod.

\item[{time}] \leavevmode{[}float{]}
Time at which equilibrium should be fetched in units of ms.

\item[{return\_geqdsk}] \leavevmode{[}bool{]}
If True, omfit\_eqdsk dictionary is also returned

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{quant\_vol\_avg}] \leavevmode{[}array, (space, …){]}
Volume average of the quantity given as an input, in the same units as in the input.
If extrapolation beyond the range available from EFIT volume averages over a shorter section
of the radial grid will be attempted. This does not affect volume averages within the LCFS.

\item[{geqdsk}] \leavevmode{[}dict{]}
Only returned if return\_geqdsk=True.

\end{description}

\end{description}

\end{fulllineitems}



\subsection{aurora.source\_utils module}
\label{\detokenize{aurora:module-aurora.source_utils}}\label{\detokenize{aurora:aurora-source-utils-module}}\index{module@\spxentry{module}!aurora.source\_utils@\spxentry{aurora.source\_utils}}\index{aurora.source\_utils@\spxentry{aurora.source\_utils}!module@\spxentry{module}}
Methods related to impurity source functions.

sciortino, 2020
\index{get\_aurora\_source() (in module aurora.source\_utils)@\spxentry{get\_aurora\_source()}\spxextra{in module aurora.source\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.source_utils.get_aurora_source}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.source\_utils.}}\sphinxbfcode{\sphinxupquote{get\_aurora\_source}}}{\emph{\DUrole{n}{namelist}}, \emph{\DUrole{n}{time}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Load source function based on current state of the namelist.

The “time” argument is only needed for time\sphinxhyphen{}dependent sources

\end{fulllineitems}

\index{get\_radial\_source() (in module aurora.source\_utils)@\spxentry{get\_radial\_source()}\spxextra{in module aurora.source\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.source_utils.get_radial_source}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.source\_utils.}}\sphinxbfcode{\sphinxupquote{get\_radial\_source}}}{\emph{\DUrole{n}{namelist}}, \emph{\DUrole{n}{radius\_grid}}, \emph{\DUrole{n}{S}}, \emph{\DUrole{n}{pro}}, \emph{\DUrole{n}{Ti}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Obtain spatial dependence of source function.

If namelist{[}‘source\_width\_in’{]}==0 and namelist{[}‘source\_width\_out’{]}==0, the source
radial profile is defined as an exponential decay due to ionization of neutrals. This requires
S, the ionization rate of neutral impurities, to be given with S.shape=(len(radius\_grid),)

If axkopt=True, the neutrals speed is taken as the thermal speed based on Ti, otherwise
the value corresponding to the namelist{[}‘imp\_energy’{]} energy is used.

This funtion reproduces the functionality of neutrals.f of STRAHL.

\end{fulllineitems}

\index{lbo\_source\_function() (in module aurora.source\_utils)@\spxentry{lbo\_source\_function()}\spxextra{in module aurora.source\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.source_utils.lbo_source_function}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.source\_utils.}}\sphinxbfcode{\sphinxupquote{lbo\_source\_function}}}{\emph{\DUrole{n}{t\_start}}, \emph{\DUrole{n}{t\_rise}}, \emph{\DUrole{n}{t\_fall}}, \emph{\DUrole{n}{n\_particles}\DUrole{o}{=}\DUrole{default_value}{1.0}}, \emph{\DUrole{n}{time\_vec}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Model for the expected shape of the time\sphinxhyphen{}dependent source function,
using a convolution of a gaussian and an exponential decay.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{t\_start}] \leavevmode{[}float or array\sphinxhyphen{}like {[}ms{]}{]}
Injection time, beginning of source rise. If multiple values are given, they are
used to create multiple source functions.

\item[{t\_rise}] \leavevmode{[}float or array\sphinxhyphen{}like {[}ms{]}{]}
Time scale of source rise. Similarly to t\_start for multiple values.

\item[{t\_fall}] \leavevmode{[}float or array\sphinxhyphen{}like {[}ms{]}{]}
Time scale of source decay.Similarly to t\_start for multiple values.

\item[{n\_particles}] \leavevmode{[}float, opt{]}
Total number of particles in source. Similarly to t\_start for multiple values.
Defaults to 1.0.

\item[{time\_vec}] \leavevmode{[}array\sphinxhyphen{}like{]}
Time vector on which to create source function. If left to None,
use a linearly spaced time vector including the main features of the function.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{time\_vec}] \leavevmode{[}array{]}
Times for the source function of each given impurity

\item[{source}] \leavevmode{[}array{]}
Time history of the synthetized source function.

\end{description}

\end{description}

\end{fulllineitems}

\index{read\_source() (in module aurora.source\_utils)@\spxentry{read\_source()}\spxextra{in module aurora.source\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.source_utils.read_source}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.source\_utils.}}\sphinxbfcode{\sphinxupquote{read\_source}}}{\emph{\DUrole{n}{filename}}}{}
Read a STRAHL source file from \{imp\}flx\{shot\}.dat locally.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{filename}] \leavevmode{[}str {]}
Location of the file containing the STRAHL source file.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{t}] \leavevmode{[}array of float, (\sphinxtitleref{n},){]}
The timebase (in seconds).

\item[{s}] \leavevmode{[}array of float, (\sphinxtitleref{n},){]}
The source function (\#/s).

\end{description}

\end{description}

\end{fulllineitems}

\index{write\_source() (in module aurora.source\_utils)@\spxentry{write\_source()}\spxextra{in module aurora.source\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.source_utils.write_source}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.source\_utils.}}\sphinxbfcode{\sphinxupquote{write\_source}}}{\emph{\DUrole{n}{t}}, \emph{\DUrole{n}{s}}, \emph{\DUrole{n}{shot}}, \emph{\DUrole{n}{imp}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}Ca\textquotesingle{}}}}{}
Write a STRAHL source file.

This will overwrite any \{imp\}flx\{shot\}.dat locally.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{t}] \leavevmode{[}array of float, (\sphinxtitleref{n},){]}
The timebase (in seconds).

\item[{s}] \leavevmode{[}array of float, (\sphinxtitleref{n},){]}
The source function (in particles/s).

\item[{shot}] \leavevmode{[}int{]}
Shot number, only used for saving to a .dat file

\item[{imp}] \leavevmode{[}str, optional{]}
Impurity species atomic symbol

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{contents}] \leavevmode{[}str{]}
Content of the source file written to \{imp\}flx\{shot\}.dat

\end{description}

\end{description}

\end{fulllineitems}



\subsection{aurora.plot\_tools module}
\label{\detokenize{aurora:module-aurora.plot_tools}}\label{\detokenize{aurora:aurora-plot-tools-module}}\index{module@\spxentry{module}!aurora.plot\_tools@\spxentry{aurora.plot\_tools}}\index{aurora.plot\_tools@\spxentry{aurora.plot\_tools}!module@\spxentry{module}}\index{get\_ls\_cycle() (in module aurora.plot\_tools)@\spxentry{get\_ls\_cycle()}\spxextra{in module aurora.plot\_tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.plot_tools.get_ls_cycle}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.plot\_tools.}}\sphinxbfcode{\sphinxupquote{get\_ls\_cycle}}}{}{}
\end{fulllineitems}

\index{slider\_plot() (in module aurora.plot\_tools)@\spxentry{slider\_plot()}\spxextra{in module aurora.plot\_tools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.plot_tools.slider_plot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.plot\_tools.}}\sphinxbfcode{\sphinxupquote{slider\_plot}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{z}}, \emph{\DUrole{n}{xlabel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{ylabel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{zlabel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{labels}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot\_sum}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{x\_line}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{y\_line}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Make a plot to explore multidimensional data.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{x}] \leavevmode{[}array of float, (\sphinxtitleref{M},){]}
The abscissa. (in aurora, often this may be rhop)

\item[{y}] \leavevmode{[}array of float, (\sphinxtitleref{N},){]}
The variable to slide over. (in aurora, often this may be time)

\item[{z}] \leavevmode{[}array of float, (\sphinxtitleref{P}, \sphinxtitleref{M}, \sphinxtitleref{N}){]}
The variables to plot.

\item[{xlabel}] \leavevmode{[}str, optional{]}
The label for the abscissa.

\item[{ylabel}] \leavevmode{[}str, optional{]}
The label for the slider.

\item[{zlabel}] \leavevmode{[}str, optional{]}
The label for the ordinate.

\item[{labels}] \leavevmode{[}list of str with length \sphinxtitleref{P}{]}
The labels for each curve in \sphinxtitleref{z}.

\item[{plot\_sum}] \leavevmode{[}bool, optional{]}
If True, will also plot the sum over all \sphinxtitleref{P} cases. Default is False.

\item[{x\_line}] \leavevmode{[}float, optional{]}
x coordinate at which a vertical line will be drawn.

\item[{y\_line}] \leavevmode{[}float, optional{]}
y coordinate at which a horizontal line will be drawn.

\end{description}

\end{description}

\end{fulllineitems}



\subsection{aurora.default\_nml module}
\label{\detokenize{aurora:module-aurora.default_nml}}\label{\detokenize{aurora:aurora-default-nml-module}}\index{module@\spxentry{module}!aurora.default\_nml@\spxentry{aurora.default\_nml}}\index{aurora.default\_nml@\spxentry{aurora.default\_nml}!module@\spxentry{module}}
Method to load default namelist. This should be complemented with additional info 
by each user.

sciortino, July 2020
\index{load\_default\_namelist() (in module aurora.default\_nml)@\spxentry{load\_default\_namelist()}\spxextra{in module aurora.default\_nml}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.default_nml.load_default_namelist}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.default\_nml.}}\sphinxbfcode{\sphinxupquote{load\_default\_namelist}}}{}{}
Load default namelist. 
Users should modify and complement this for a successful run.

\end{fulllineitems}



\subsection{aurora.interp module}
\label{\detokenize{aurora:module-aurora.interp}}\label{\detokenize{aurora:aurora-interp-module}}\index{module@\spxentry{module}!aurora.interp@\spxentry{aurora.interp}}\index{aurora.interp@\spxentry{aurora.interp}!module@\spxentry{module}}
This script contains a number of functions used for interpolation of kinetic profiles and D,V profiles in STRAHL.
Refer to the STRAHL manual for details.
\index{exppol0() (in module aurora.interp)@\spxentry{exppol0()}\spxextra{in module aurora.interp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.interp.exppol0}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.interp.}}\sphinxbfcode{\sphinxupquote{exppol0}}}{\emph{\DUrole{n}{params}}, \emph{\DUrole{n}{d}}, \emph{\DUrole{n}{rLCFS}}, \emph{\DUrole{n}{r}}}{}
\end{fulllineitems}

\index{exppol1() (in module aurora.interp)@\spxentry{exppol1()}\spxextra{in module aurora.interp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.interp.exppol1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.interp.}}\sphinxbfcode{\sphinxupquote{exppol1}}}{\emph{\DUrole{n}{params}}, \emph{\DUrole{n}{d}}, \emph{\DUrole{n}{rLCFS}}, \emph{\DUrole{n}{r}}}{}
\end{fulllineitems}

\index{funct() (in module aurora.interp)@\spxentry{funct()}\spxextra{in module aurora.interp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.interp.funct}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.interp.}}\sphinxbfcode{\sphinxupquote{funct}}}{\emph{\DUrole{n}{params}}, \emph{\DUrole{n}{rLCFS}}, \emph{\DUrole{n}{r}}}{}
Function ‘funct’ in STRAHL manual
\begin{description}
\item[{The “params” input is broken down into 6 arguments:}] \leavevmode
y0 is core offset
y1 is edge offset
y2 (\textgreater{}y0, \textgreater{}y1) sets the gaussian amplification
p0 sets the width of the inner gaussian
P1 sets the width of the outer gaussian
p2 sets the location of the inner and outer peaks

\end{description}

\end{fulllineitems}

\index{funct2() (in module aurora.interp)@\spxentry{funct2()}\spxextra{in module aurora.interp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.interp.funct2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.interp.}}\sphinxbfcode{\sphinxupquote{funct2}}}{\emph{\DUrole{n}{params}}, \emph{\DUrole{n}{rLCFS}}, \emph{\DUrole{n}{r}}}{}
Function ‘funct2’ in STRAHL manual.

\end{fulllineitems}

\index{interp() (in module aurora.interp)@\spxentry{interp()}\spxextra{in module aurora.interp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.interp.interp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.interp.}}\sphinxbfcode{\sphinxupquote{interp}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{rLCFS}}, \emph{\DUrole{n}{r}}}{}
Function ‘interp’ used in STRAHL for D and V profiles.

\end{fulllineitems}

\index{interp\_quad() (in module aurora.interp)@\spxentry{interp\_quad()}\spxextra{in module aurora.interp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.interp.interp_quad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.interp.}}\sphinxbfcode{\sphinxupquote{interp\_quad}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{d}}, \emph{\DUrole{n}{rLCFS}}, \emph{\DUrole{n}{r}}}{}
Function ‘interp’ used for kinetic profiles.

\end{fulllineitems}

\index{interpa\_quad() (in module aurora.interp)@\spxentry{interpa\_quad()}\spxextra{in module aurora.interp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.interp.interpa_quad}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.interp.}}\sphinxbfcode{\sphinxupquote{interpa\_quad}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{rLCFS}}, \emph{\DUrole{n}{r}}}{}
Function ‘interpa’ used for kinetic profiles

\end{fulllineitems}

\index{ratfun() (in module aurora.interp)@\spxentry{ratfun()}\spxextra{in module aurora.interp}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.interp.ratfun}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.interp.}}\sphinxbfcode{\sphinxupquote{ratfun}}}{\emph{\DUrole{n}{params}}, \emph{\DUrole{n}{d}}, \emph{\DUrole{n}{rLCFS}}, \emph{\DUrole{n}{r}}}{}
\end{fulllineitems}



\subsection{aurora.animate module}
\label{\detokenize{aurora:module-aurora.animate}}\label{\detokenize{aurora:aurora-animate-module}}\index{module@\spxentry{module}!aurora.animate@\spxentry{aurora.animate}}\index{aurora.animate@\spxentry{aurora.animate}!module@\spxentry{module}}\index{animate\_aurora() (in module aurora.animate)@\spxentry{animate\_aurora()}\spxextra{in module aurora.animate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.animate.animate_aurora}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.animate.}}\sphinxbfcode{\sphinxupquote{animate\_aurora}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{z}}, \emph{\DUrole{n}{xlabel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{ylabel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{zlabel}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{labels}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plot\_sum}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{uniform\_y\_spacing}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{save\_filename}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Produce animation of time\sphinxhyphen{} and radially\sphinxhyphen{}dependent results from aurora.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{x}] \leavevmode{[}array of float, (\sphinxtitleref{M},){]}
The abscissa. (in aurora, often this may be rhop)

\item[{y}] \leavevmode{[}array of float, (\sphinxtitleref{N},){]}
The variable to slide over. (in aurora, often this may be time)

\item[{z}] \leavevmode{[}array of float, (\sphinxtitleref{P}, \sphinxtitleref{M}, \sphinxtitleref{N}){]}
The variables to plot.

\item[{xlabel}] \leavevmode{[}str, optional{]}
The label for the abscissa.

\item[{ylabel}] \leavevmode{[}str, optional{]}
The label for the animated coordinate. This is expected in a format such that ylabel.format(y\_val)
will display a good moving label, e.g. ylabel=’t=\{:.4f\} s’.

\item[{zlabel}] \leavevmode{[}str, optional{]}
The label for the ordinate.

\item[{labels}] \leavevmode{[}list of str with length \sphinxtitleref{P}{]}
The labels for each curve in \sphinxtitleref{z}.

\item[{plot\_sum}] \leavevmode{[}bool, optional{]}
If True, will also plot the sum over all \sphinxtitleref{P} cases. Default is False.

\item[{uniform\_y\_spacing}] \leavevmode{[}bool, optional{]}
If True, interpolate values in z onto a uniformly\sphinxhyphen{}spaced y grid

\item[{save\_filename}] \leavevmode{[}str{]}
If a valid path/filename is provided, the animation will be saved here in mp4 format.

\end{description}

\end{description}

\end{fulllineitems}



\subsection{aurora.particle\_conserv module}
\label{\detokenize{aurora:module-aurora.particle_conserv}}\label{\detokenize{aurora:aurora-particle-conserv-module}}\index{module@\spxentry{module}!aurora.particle\_conserv@\spxentry{aurora.particle\_conserv}}\index{aurora.particle\_conserv@\spxentry{aurora.particle\_conserv}!module@\spxentry{module}}\index{get\_particle\_nums() (in module aurora.particle\_conserv)@\spxentry{get\_particle\_nums()}\spxextra{in module aurora.particle\_conserv}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.particle_conserv.get_particle_nums}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.particle\_conserv.}}\sphinxbfcode{\sphinxupquote{get\_particle\_nums}}}{\emph{\DUrole{n}{filepath}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ds}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{R\_axis}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Check time evolution and particle conservation in (py)STRAHL output.
If filepath is None, load data from output STRAHL file, otherwise use xarray Dataset in ds.

R\_axis {[}cm{]} is needed for volume integrals. If None, it is set to a C\sphinxhyphen{}Mod default.

\end{fulllineitems}

\index{plot\_1d() (in module aurora.particle\_conserv)@\spxentry{plot\_1d()}\spxextra{in module aurora.particle\_conserv}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.particle_conserv.plot_1d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.particle\_conserv.}}\sphinxbfcode{\sphinxupquote{plot\_1d}}}{\emph{\DUrole{n}{filepath}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ds}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{linestyle}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\sphinxhyphen{}\textquotesingle{}}}, \emph{\DUrole{n}{axs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{R\_axis}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Check time evolution and particle conservation in (py)STRAHL output.

If filepath is None, load data from output STRAHL file, otherwise use xarray Dataset in ds.

If axs is passed, it is assumed that this is a tuple of 2 set of axes: the first one for the separate 
particle time variation in each reservoir, the second for the total particle\sphinxhyphen{}conservation check.

R\_axis {[}cm{]} is the major radius, used for volume integrals. If None, it is set to a C\sphinxhyphen{}Mod default.

\end{fulllineitems}

\index{plot\_particle\_conserv() (in module aurora.particle\_conserv)@\spxentry{plot\_particle\_conserv()}\spxextra{in module aurora.particle\_conserv}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.particle_conserv.plot_particle_conserv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.particle\_conserv.}}\sphinxbfcode{\sphinxupquote{plot\_particle\_conserv}}}{\emph{\DUrole{n}{res}}, \emph{\DUrole{n}{ax}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Plot number of particles in each Aurora simulation reservoir.

\end{fulllineitems}

\index{vol\_int() (in module aurora.particle\_conserv)@\spxentry{vol\_int()}\spxextra{in module aurora.particle\_conserv}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.particle_conserv.vol_int}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.particle\_conserv.}}\sphinxbfcode{\sphinxupquote{vol\_int}}}{\emph{\DUrole{n}{ds}}, \emph{\DUrole{n}{var}}, \emph{\DUrole{n}{rhop\_max}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{R\_axis}\DUrole{o}{=}\DUrole{default_value}{68.5}}}{}
Perform a volume integral of an input variable. If the variable is f(t,x) then the result is f(t).
If the variable is f(t,*,x) then the result is f(t,charge) when “*” represents charge, line index, etc…
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ds}} \textendash{} xarray dataset containing STRAHL result

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{var}} \textendash{} Name of the variable in the strahl\_result.cdf file

\end{itemize}

\item[{Params rhop\_max}] \leavevmode
Maximum normalized poloidal flux for integral

\item[{Params R\_axis}] \leavevmode
major radius on axis {[}cm{]}

\item[{Returns}] \leavevmode
Time history of volume integrated variable

\end{description}\end{quote}

\end{fulllineitems}



\subsection{aurora.nbi\_neutrals module}
\label{\detokenize{aurora:module-aurora.nbi_neutrals}}\label{\detokenize{aurora:aurora-nbi-neutrals-module}}\index{module@\spxentry{module}!aurora.nbi\_neutrals@\spxentry{aurora.nbi\_neutrals}}\index{aurora.nbi\_neutrals@\spxentry{aurora.nbi\_neutrals}!module@\spxentry{module}}
Methods for neutral beam analysis, particularly in relation to impurity transport studies.
These script collects functions that should be device\sphinxhyphen{}agnostic.
\index{beam\_grid() (in module aurora.nbi\_neutrals)@\spxentry{beam\_grid()}\spxextra{in module aurora.nbi\_neutrals}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.nbi_neutrals.beam_grid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.nbi\_neutrals.}}\sphinxbfcode{\sphinxupquote{beam\_grid}}}{\emph{\DUrole{n}{uvw\_src}}, \emph{\DUrole{n}{axis}}, \emph{\DUrole{n}{max\_radius}\DUrole{o}{=}\DUrole{default_value}{255.0}}}{}
Method to obtain the 3D orientation of a beam with respect to the device.
The uvw\_src and (normalized) axis arrays may be obtained from the d3d\_beams method
of fidasim\_lib.py in the FIDASIM module in OMFIT.

This is inspired by \sphinxtitleref{beam\_grid} in fidasim\_lib.py of the FIDASIM module (S. Haskey) 
in OMFIT.

\end{fulllineitems}

\index{bt\_rate\_maxwell\_average() (in module aurora.nbi\_neutrals)@\spxentry{bt\_rate\_maxwell\_average()}\spxextra{in module aurora.nbi\_neutrals}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.nbi_neutrals.bt_rate_maxwell_average}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.nbi\_neutrals.}}\sphinxbfcode{\sphinxupquote{bt\_rate\_maxwell\_average}}}{\emph{\DUrole{n}{sigma\_fun}}, \emph{\DUrole{n}{Ti}}, \emph{\DUrole{n}{E\_beam}}, \emph{\DUrole{n}{m\_bckg}}, \emph{\DUrole{n}{m\_beam}}, \emph{\DUrole{n}{n\_level}}}{}
Calculates Maxwellian reaction rate for a beam with atomic mass “m\_beam”, 
energy “E\_beam”, firing into a target with atomic mass “m\_bckg” and temperature “T”.

The “sigma\_fun” argument must be a function for a specific charge and n\sphinxhyphen{}level of the beam particles.
Ref: FIDASIM atomic\_tables.f90 bt\_maxwellian\_n\_m.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{sigma\_fun: :py:meth}] \leavevmode
Function to compute a specific cross section {[}cm\textasciicircum{}2{]}, function of energy/amu ONLY.
Expected call form: sigma\_fun(erel/ared)

\item[{Ti}] \leavevmode{[}float, 1D or 2D array{]}
Target temperature {[}keV{]}. Results will be computed for each Ti value in a vectorized manner.

\item[{E\_beam}] \leavevmode{[}float{]}
Beam energy {[}keV{]}

\item[{m\_bckg}] \leavevmode{[}float{]}
Target atomic mass {[}amu{]}

\item[{m\_beam}] \leavevmode{[}float{]}
Beam atomic mass {[}amu{]}

\item[{n\_level :int}] \leavevmode
n\sphinxhyphen{}level of beam. This is used to evaluate the hydrogen ionization potential,
below which an electron is unlikely to charge exchange with surrounding ions.

\end{description}

\item[{Returns:}] \leavevmode
rate : output reaction rate in {[}cm\textasciicircum{}3/s{]} units

\end{description}

\end{fulllineitems}

\index{bt\_rate\_maxwell\_average\_vec() (in module aurora.nbi\_neutrals)@\spxentry{bt\_rate\_maxwell\_average\_vec()}\spxextra{in module aurora.nbi\_neutrals}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.nbi_neutrals.bt_rate_maxwell_average_vec}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.nbi\_neutrals.}}\sphinxbfcode{\sphinxupquote{bt\_rate\_maxwell\_average\_vec}}}{\emph{\DUrole{n}{sigma\_fun}}, \emph{\DUrole{n}{Ti}}, \emph{\DUrole{n}{E\_beam}}, \emph{\DUrole{n}{m\_bckg}}, \emph{\DUrole{n}{m\_beam}}, \emph{\DUrole{n}{n\_level}}}{}
Calculates Maxwellian reaction rate for a beam with atomic mass “m\_beam”, 
energy “E\_beam”, firing into a target with atomic mass “m\_bckg” and temperature “T”.

The “sigma\_fun” argument must be a function for a specific charge and n\sphinxhyphen{}level of the beam particles.
Ref: FIDASIM atomic\_tables.f90 bt\_maxwellian\_n\_m.

This version of the function attempts to vectorize the calculation such that we can have Ti
being a function of space and time and deal with integrations in vr and vz with no loops.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{sigma\_fun: :py:meth}] \leavevmode
Function to compute a specific cross section {[}cm\textasciicircum{}2{]}, function of energy/amu ONLY.
Expected call form: sigma\_fun(erel/ared)

\item[{Ti}] \leavevmode{[}float, 1D or 2D array{]}
Target temperature {[}keV{]}

\item[{E\_beam}] \leavevmode{[}float{]}
Beam energy {[}keV{]}

\item[{m\_bckg}] \leavevmode{[}float{]}
Target atomic mass {[}amu{]}

\item[{m\_beam}] \leavevmode{[}float{]}
Beam atomic mass {[}amu{]}

\item[{n\_level}] \leavevmode{[}int{]}
n\sphinxhyphen{}level of beam. This is used to evaluate the hydrogen ionization potential,
below which an electron is unlikely to charge exchange with surrounding ions.

\end{description}

\item[{Returns:}] \leavevmode
rate : output reaction rate in {[}cm\textasciicircum{}3/s{]} units

\end{description}

\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{} UNTESTED!\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}

\end{fulllineitems}

\index{get\_NBI\_imp\_cxr\_q() (in module aurora.nbi\_neutrals)@\spxentry{get\_NBI\_imp\_cxr\_q()}\spxextra{in module aurora.nbi\_neutrals}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.nbi_neutrals.get_NBI_imp_cxr_q}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.nbi\_neutrals.}}\sphinxbfcode{\sphinxupquote{get\_NBI\_imp\_cxr\_q}}}{\emph{\DUrole{n}{neut\_fsa}}, \emph{\DUrole{n}{q}}, \emph{\DUrole{n}{rhop\_Ti}}, \emph{\DUrole{n}{times\_Ti}}, \emph{\DUrole{n}{Ti\_prof}}, \emph{\DUrole{n}{include\_fast}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{include\_halo}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{debug\_plots}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Compute flux\sphinxhyphen{}surface\sphinxhyphen{}averaged (FSA) charge exchange recombination for a given impurity with
neutral beam components, applying appropriate Maxwellian averaging of cross sections and
obtaining rates in {[}s\textasciicircum{}\sphinxhyphen{}1{]} units. This method expects all neutral components to be given in a
dictionary with a structure that is independent of NBI model.

Note that while Ti may be time\sphinxhyphen{}dependent, with a time base given by times\_Ti, the FSA
neutrals are expected to be time\sphinxhyphen{}independent. Hence, the resulting CXR rates will only have
time dependence that reflects changes in Ti, but not the NBI.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{neut\_fsa}] \leavevmode{[}dict{]}
Dictionary containing FSA neutral densities in the form that is output by {\hyperref[\detokenize{aurora:aurora.nbi_neutrals.get_neutrals_fsa}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_neutrals\_fsa()}}}}}.

\item[{q}] \leavevmode{[}int or float{]}
Charge of impurity species

\item[{rhop\_Ti}] \leavevmode{[}array\sphinxhyphen{}like{]}
Sqrt of poloidal flux radial coordinate for Ti profiles.

\item[{times\_Ti}] \leavevmode{[}array\sphinxhyphen{}like{]}
Time base on which Ti\_prof is given {[}s{]}.

\item[{Ti\_prof}] \leavevmode{[}array\sphinxhyphen{}like{]}
Ion temperature profile on the rhop\_Ti, times\_Ti bases.

\item[{include\_fast}] \leavevmode{[}bool, optional{]}
If True, include CXR rates from fast NBI neutrals. Default is True.

\item[{include\_halo}] \leavevmode{[}bool, optional{]}
If True, include CXR rates from themral NBI halo neutrals. Default is True.

\item[{debug\_plots}] \leavevmode{[}bool, optional{]}
If True, plot several plots to assess the quality of the calculation.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{rates}] \leavevmode{[}dict{]}
Dictionary containing CXR rates from NBI neutrals. This dictionary has analogous form to the 
{\hyperref[\detokenize{aurora:aurora.nbi_neutrals.get_neutrals_fsa}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_neutrals\_fsa()}}}}} function, e.g. we have

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rates}\PYG{p}{[}\PYG{n}{beam}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n=}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{n\PYGZus{}level}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{halo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

Rates are on a radial grid corresponding to the input neut\_fsa{[}‘rhop’{]}.

\end{description}

\end{description}

For details on inputs and outputs, it is recommendeded to look at the internal plotting functions.

\end{fulllineitems}

\index{get\_ls\_cycle() (in module aurora.nbi\_neutrals)@\spxentry{get\_ls\_cycle()}\spxextra{in module aurora.nbi\_neutrals}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.nbi_neutrals.get_ls_cycle}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.nbi\_neutrals.}}\sphinxbfcode{\sphinxupquote{get\_ls\_cycle}}}{}{}
\end{fulllineitems}

\index{get\_neutrals\_fsa() (in module aurora.nbi\_neutrals)@\spxentry{get\_neutrals\_fsa()}\spxextra{in module aurora.nbi\_neutrals}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.nbi_neutrals.get_neutrals_fsa}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.nbi\_neutrals.}}\sphinxbfcode{\sphinxupquote{get\_neutrals\_fsa}}}{\emph{\DUrole{n}{neutrals}}, \emph{\DUrole{n}{geqdsk}}, \emph{\DUrole{n}{debug\_plots}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Compute charge exchange recombination for a given impurity with neutral beam components,
obtaining rates in {[}s\textasciicircum{}\sphinxhyphen{}1{]} units. This method expects all neutral components to be given in a
dictionary with a structure that is independent of NBI model (i.e. coming from FIDASIM, NUBEAM, 
pencil calculations, etc.).
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{neutrals}] \leavevmode{[}dict{]}
Dictionary containing fields
\{“beams”,”names”,”R”,”Z”, beam1, beam2, etc.\}
Here beam1,beam2,etc. are the names in neutrals{[}“beams”{]}. “names” are the names of each 
beam component, e.g. ‘fdens’,’hdens’,’halo’, etc., ordered according to “names”. 
“R”,”Z” are the major radius and vertical coordinates {[}cm{]} on which neutral density components are 
given in elements such as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{neutrals}\PYG{p}{[}\PYG{n}{beams}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{n=0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{name\PYGZus{}idx}\PYG{p}{]}
\end{sphinxVerbatim}

It is currently assumed that n=0,1 and 2 beam components are provided by the user.

\end{description}

geqdsk : gEQDSK post\sphinxhyphen{}processed dictionary, as given by the omfit\_eqdsk package.
\begin{description}
\item[{debug\_plots}] \leavevmode{[}bool, optional{]}
If True, various plots are displayed.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{neut\_fsa}] \leavevmode{[}dict{]}
Dictionary of flux\sphinxhyphen{}surface\sphinxhyphen{}averaged (FSA) neutral densities, in the same units as in the input. 
Similarly to the input “neutrals”, this dictionary has a structure like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{neutrals\PYGZus{}ext}\PYG{p}{[}\PYG{n}{beam}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n=}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{n\PYGZus{}level}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{name\PYGZus{}idx}\PYG{p}{]}
\end{sphinxVerbatim}

\end{description}

\end{description}

\end{fulllineitems}

\index{rotation\_matrix() (in module aurora.nbi\_neutrals)@\spxentry{rotation\_matrix()}\spxextra{in module aurora.nbi\_neutrals}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.nbi_neutrals.rotation_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.nbi\_neutrals.}}\sphinxbfcode{\sphinxupquote{rotation\_matrix}}}{\emph{\DUrole{n}{alpha}}, \emph{\DUrole{n}{beta}}, \emph{\DUrole{n}{gamma}}}{}
See the table of all rotation possiblities, on the Tait Bryan side
\sphinxurl{https://en.wikipedia.org/wiki/Euler\_angles\#Tait.E2.80.93Bryan\_angles}

\end{fulllineitems}

\index{tt\_rate\_maxwell\_average() (in module aurora.nbi\_neutrals)@\spxentry{tt\_rate\_maxwell\_average()}\spxextra{in module aurora.nbi\_neutrals}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.nbi_neutrals.tt_rate_maxwell_average}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.nbi\_neutrals.}}\sphinxbfcode{\sphinxupquote{tt\_rate\_maxwell\_average}}}{\emph{\DUrole{n}{sigma\_fun}}, \emph{\DUrole{n}{Ti}}, \emph{\DUrole{n}{m\_i}}, \emph{\DUrole{n}{m\_n}}, \emph{\DUrole{n}{n\_level}}}{}
Calculates Maxwellian reaction rate for an interaction between two thermal populations,
assumed to be of neutrals (mass m\_n) and background ions (mass m\_i).

The ‘sigma\_fun’ argument must be a function for a specific charge and n\sphinxhyphen{}level of the neutral 
particles. This allows evaluation of atomic rates for charge exchange interactions between thermal
beam halos and background ions.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{sigma\_fun: python function}] \leavevmode
Function to compute a specific cross section {[}cm\textasciicircum{}2{]}, function of energy/amu ONLY.
Expected call form: sigma\_fun(erel/ared)

\item[{Ti: float or 1D array}] \leavevmode
background ion and halo temperature {[}keV{]}

\item[{m\_i: float}] \leavevmode
mass of background ions {[}amu{]}

\item[{m\_n: float }] \leavevmode
mass of neutrals {[}amu{]}

\item[{n\_level: int}] \leavevmode
n\sphinxhyphen{}level of beam. This is used to evaluate the hydrogen ionization potential,
below which an electron is unlikely to charge exchange with surrounding ions.

\end{description}

TODO: add effect of toroidal rotation! This will require making the integration in this
function 2\sphinxhyphen{}dimensional.

\item[{Returns:}] \leavevmode\begin{description}
\item[{rate}] \leavevmode{[}float or 1D array{]}
output reaction rate in {[}cm\textasciicircum{}3/s{]} units

\end{description}

\end{description}

\end{fulllineitems}

\index{uvw\_xyz() (in module aurora.nbi\_neutrals)@\spxentry{uvw\_xyz()}\spxextra{in module aurora.nbi\_neutrals}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.nbi_neutrals.uvw_xyz}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.nbi\_neutrals.}}\sphinxbfcode{\sphinxupquote{uvw\_xyz}}}{\emph{\DUrole{n}{u}}, \emph{\DUrole{n}{v}}, \emph{\DUrole{n}{w}}, \emph{\DUrole{n}{origin}}, \emph{\DUrole{n}{R}}}{}
Computes array elements by multiplying the rows of the first
array by the columns of the second array. The second array
must have the same number of rows as the first array has
columns. The resulting array has the same number of rows as
the first array and the same number of columns as the second
array.

See uvw\_to\_xyz in fidasim.f90

\end{fulllineitems}

\index{xyz\_uvw() (in module aurora.nbi\_neutrals)@\spxentry{xyz\_uvw()}\spxextra{in module aurora.nbi\_neutrals}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.nbi_neutrals.xyz_uvw}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.nbi\_neutrals.}}\sphinxbfcode{\sphinxupquote{xyz\_uvw}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{z}}, \emph{\DUrole{n}{origin}}, \emph{\DUrole{n}{R}}}{}
Computes array elements by multiplying the rows of the first
array by the columns of the second array. The second array
must have the same number of rows as the first array has
columns. The resulting array has the same number of rows as
the first array and the same number of columns as the second
array.

See xyz\_to\_uvw in fidasim.f90

\end{fulllineitems}



\subsection{aurora.janev\_smith\_rates module}
\label{\detokenize{aurora:module-aurora.janev_smith_rates}}\label{\detokenize{aurora:aurora-janev-smith-rates-module}}\index{module@\spxentry{module}!aurora.janev\_smith\_rates@\spxentry{aurora.janev\_smith\_rates}}\index{aurora.janev\_smith\_rates@\spxentry{aurora.janev\_smith\_rates}!module@\spxentry{module}}
Script collecting rates from Janev \& Smith, NF 1993. 
These are useful in aurora to compute total (n\sphinxhyphen{}unresolved) charge exchange rates between heavy ions and neutrals.

sciortino, 2020
\index{js\_sigma() (in module aurora.janev\_smith\_rates)@\spxentry{js\_sigma()}\spxextra{in module aurora.janev\_smith\_rates}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.janev_smith_rates.js_sigma}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.janev\_smith\_rates.}}\sphinxbfcode{\sphinxupquote{js\_sigma}}}{\emph{\DUrole{n}{E}}, \emph{\DUrole{n}{q}}, \emph{\DUrole{n}{n1}}, \emph{\DUrole{n}{n2}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}cx\textquotesingle{}}}}{}
Cross sections for collisional processes between beam neutrals and highly\sphinxhyphen{}charged 
ions, from Janev \& Smith 1993.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{E}] \leavevmode{[}float{]}
Normalized beam energy {[}keV/amu{]}

\item[{q}] \leavevmode{[}int{]}
Impurity charge before interaction (interacting ion is A\textasciicircum{}\{q+\})

\item[{n1}] \leavevmode{[}int{]}
Principal quantum number of beam hydrogen.

\item[{n2: int}] \leavevmode
Principal quantum number of excited. This may not be needed for some transitions (if so, leave to None).

\item[{type}] \leavevmode{[}str{]}
Type of interaction. Possible choices:
\{‘exc’,’ioniz’,’cx’\}
where ‘cx’ refers to electron capture / charge exchange.

\end{description}

\item[{Returns:}] \leavevmode\begin{description}
\item[{sigma}] \leavevmode{[}float{]}
Cross section of selected process, in {[}cm\textasciicircum{}2{]} units.

\end{description}

\end{description}

See comments in Janev \& Smith 1993 for uncertainty estimates.

\end{fulllineitems}

\index{js\_sigma\_cx\_n1\_q1() (in module aurora.janev\_smith\_rates)@\spxentry{js\_sigma\_cx\_n1\_q1()}\spxextra{in module aurora.janev\_smith\_rates}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.janev_smith_rates.js_sigma_cx_n1_q1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.janev\_smith\_rates.}}\sphinxbfcode{\sphinxupquote{js\_sigma\_cx\_n1\_q1}}}{\emph{\DUrole{n}{E}}}{}
Electron capture cross section for
H\textasciicircum{}\{+\} + H(1s) \textendash{}\textgreater{} H + H\textasciicircum{}+
Section 2.3.1

\end{fulllineitems}

\index{js\_sigma\_cx\_n1\_q2() (in module aurora.janev\_smith\_rates)@\spxentry{js\_sigma\_cx\_n1\_q2()}\spxextra{in module aurora.janev\_smith\_rates}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.janev_smith_rates.js_sigma_cx_n1_q2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.janev\_smith\_rates.}}\sphinxbfcode{\sphinxupquote{js\_sigma\_cx\_n1\_q2}}}{\emph{\DUrole{n}{E}}}{}
Electron capture cross section for
He\textasciicircum{}\{2+\} + H(1s) \textendash{}\textgreater{} He\textasciicircum{}+ + H\textasciicircum{}+
Section 3.3.1

\end{fulllineitems}

\index{js\_sigma\_cx\_n1\_q4() (in module aurora.janev\_smith\_rates)@\spxentry{js\_sigma\_cx\_n1\_q4()}\spxextra{in module aurora.janev\_smith\_rates}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.janev_smith_rates.js_sigma_cx_n1_q4}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.janev\_smith\_rates.}}\sphinxbfcode{\sphinxupquote{js\_sigma\_cx\_n1\_q4}}}{\emph{\DUrole{n}{E}}}{}
Electron capture cross section for
Be\textasciicircum{}\{4+\} + H(1s) \textendash{}\textgreater{} Be\textasciicircum{}\{3+\} + H\textasciicircum{}+
Section 4.3.1

\end{fulllineitems}

\index{js\_sigma\_cx\_n1\_q5() (in module aurora.janev\_smith\_rates)@\spxentry{js\_sigma\_cx\_n1\_q5()}\spxextra{in module aurora.janev\_smith\_rates}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.janev_smith_rates.js_sigma_cx_n1_q5}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.janev\_smith\_rates.}}\sphinxbfcode{\sphinxupquote{js\_sigma\_cx\_n1\_q5}}}{\emph{\DUrole{n}{E}}}{}
Electron capture cross section for
B\textasciicircum{}\{5+\} + H(1s) \textendash{}\textgreater{} B\textasciicircum{}\{4+\} + H\textasciicircum{}+
Section 4.3.2

\end{fulllineitems}

\index{js\_sigma\_cx\_n1\_q6() (in module aurora.janev\_smith\_rates)@\spxentry{js\_sigma\_cx\_n1\_q6()}\spxextra{in module aurora.janev\_smith\_rates}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.janev_smith_rates.js_sigma_cx_n1_q6}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.janev\_smith\_rates.}}\sphinxbfcode{\sphinxupquote{js\_sigma\_cx\_n1\_q6}}}{\emph{\DUrole{n}{E}}}{}
Electron capture cross section for
C\textasciicircum{}\{6+\} + H(1s) \textendash{}\textgreater{} C\textasciicircum{}\{5+\} + H\textasciicircum{}+
Section 4.3.3

\end{fulllineitems}

\index{js\_sigma\_cx\_n1\_q8() (in module aurora.janev\_smith\_rates)@\spxentry{js\_sigma\_cx\_n1\_q8()}\spxextra{in module aurora.janev\_smith\_rates}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.janev_smith_rates.js_sigma_cx_n1_q8}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.janev\_smith\_rates.}}\sphinxbfcode{\sphinxupquote{js\_sigma\_cx\_n1\_q8}}}{\emph{\DUrole{n}{E}}}{}
Electron capture cross section for
O\textasciicircum{}\{8+\} + H(1s) \textendash{}\textgreater{} O\textasciicircum{}\{7+\} + H\textasciicircum{}+
Section 4.3.4

\end{fulllineitems}

\index{js\_sigma\_cx\_n1\_qg8() (in module aurora.janev\_smith\_rates)@\spxentry{js\_sigma\_cx\_n1\_qg8()}\spxextra{in module aurora.janev\_smith\_rates}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.janev_smith_rates.js_sigma_cx_n1_qg8}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.janev\_smith\_rates.}}\sphinxbfcode{\sphinxupquote{js\_sigma\_cx\_n1\_qg8}}}{\emph{\DUrole{n}{E}}, \emph{\DUrole{n}{q}}}{}
Electron capture cross section for
A\textasciicircum{}\{q+\} + H(1s) \textendash{}\textgreater{} A\textasciicircum{}\{(q\sphinxhyphen{}1)+\} + H\textasciicircum{}+,   q\textgreater{}8
Section 4.3.5, p.172

\end{fulllineitems}

\index{js\_sigma\_cx\_n2\_q2() (in module aurora.janev\_smith\_rates)@\spxentry{js\_sigma\_cx\_n2\_q2()}\spxextra{in module aurora.janev\_smith\_rates}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.janev_smith_rates.js_sigma_cx_n2_q2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.janev\_smith\_rates.}}\sphinxbfcode{\sphinxupquote{js\_sigma\_cx\_n2\_q2}}}{\emph{\DUrole{n}{E}}}{}
Electron capture cross section for
He\textasciicircum{}\{2+\} + H(n=2) \textendash{}\textgreater{} He\textasciicircum{}+ + H\textasciicircum{}+
Section 3.3.2

\end{fulllineitems}

\index{js\_sigma\_cx\_ng1\_q1() (in module aurora.janev\_smith\_rates)@\spxentry{js\_sigma\_cx\_ng1\_q1()}\spxextra{in module aurora.janev\_smith\_rates}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.janev_smith_rates.js_sigma_cx_ng1_q1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.janev\_smith\_rates.}}\sphinxbfcode{\sphinxupquote{js\_sigma\_cx\_ng1\_q1}}}{\emph{\DUrole{n}{E}}, \emph{\DUrole{n}{n1}}}{}
Electron capture cross section for
H\textasciicircum{}\{+\} + H(n) \textendash{}\textgreater{} H + H\textasciicircum{}+ , n\textgreater{}1
Section 2.3.2

\end{fulllineitems}

\index{js\_sigma\_cx\_ng1\_qg3() (in module aurora.janev\_smith\_rates)@\spxentry{js\_sigma\_cx\_ng1\_qg3()}\spxextra{in module aurora.janev\_smith\_rates}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.janev_smith_rates.js_sigma_cx_ng1_qg3}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.janev\_smith\_rates.}}\sphinxbfcode{\sphinxupquote{js\_sigma\_cx\_ng1\_qg3}}}{\emph{\DUrole{n}{E}}, \emph{\DUrole{n}{n1}}, \emph{\DUrole{n}{q}}}{}
Electron capture cross section for
A\textasciicircum{}\{q+\} + H\textasciicircum{}*(n) \textendash{}\textgreater{} A\textasciicircum{}\{(q\sphinxhyphen{}1)+\}+H\textasciicircum{}+ , q\textgreater{}3
Section 4.3.6, p.174

\end{fulllineitems}

\index{js\_sigma\_cx\_ng2\_q2() (in module aurora.janev\_smith\_rates)@\spxentry{js\_sigma\_cx\_ng2\_q2()}\spxextra{in module aurora.janev\_smith\_rates}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.janev_smith_rates.js_sigma_cx_ng2_q2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.janev\_smith\_rates.}}\sphinxbfcode{\sphinxupquote{js\_sigma\_cx\_ng2\_q2}}}{\emph{\DUrole{n}{E}}, \emph{\DUrole{n}{n1}}}{}
Electron capture cross section for
He\textasciicircum{}\{2+\} + H*(n) \textendash{}\textgreater{} He\textasciicircum{}+ + H\textasciicircum{}+ , n\textgreater{}2
Section 3.2.3

\end{fulllineitems}

\index{js\_sigma\_ioniz\_n1\_q8() (in module aurora.janev\_smith\_rates)@\spxentry{js\_sigma\_ioniz\_n1\_q8()}\spxextra{in module aurora.janev\_smith\_rates}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.janev_smith_rates.js_sigma_ioniz_n1_q8}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.janev\_smith\_rates.}}\sphinxbfcode{\sphinxupquote{js\_sigma\_ioniz\_n1\_q8}}}{\emph{\DUrole{n}{E}}}{}
Ionization cross section for
O\textasciicircum{}\{8+\} + H(1s) \textendash{}\textgreater{} O\textasciicircum{}\{8+\} + H\textasciicircum{}+ +e\textasciicircum{}\sphinxhyphen{}
Section 4.2.4

\end{fulllineitems}

\index{plot\_js\_sigma() (in module aurora.janev\_smith\_rates)@\spxentry{plot\_js\_sigma()}\spxextra{in module aurora.janev\_smith\_rates}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.janev_smith_rates.plot_js_sigma}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aurora.janev\_smith\_rates.}}\sphinxbfcode{\sphinxupquote{plot\_js\_sigma}}}{\emph{\DUrole{n}{q}\DUrole{o}{=}\DUrole{default_value}{18}}}{}
\end{fulllineitems}



\subsection{Module contents}
\label{\detokenize{aurora:module-aurora}}\label{\detokenize{aurora:module-contents}}\index{module@\spxentry{module}!aurora@\spxentry{aurora}}\index{aurora@\spxentry{aurora}!module@\spxentry{module}}\index{name (in module aurora)@\spxentry{name}\spxextra{in module aurora}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{aurora:aurora.name}}\pysigline{\sphinxcode{\sphinxupquote{aurora.}}\sphinxbfcode{\sphinxupquote{name}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}aurora\textquotesingle{}}}}
{\hyperref[\detokenize{aurora:module-aurora}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{aurora}}}}}

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{a}
\item\relax\sphinxstyleindexentry{aurora}\sphinxstyleindexpageref{aurora:\detokenize{module-aurora}}
\item\relax\sphinxstyleindexentry{aurora.animate}\sphinxstyleindexpageref{aurora:\detokenize{module-aurora.animate}}
\item\relax\sphinxstyleindexentry{aurora.atomic}\sphinxstyleindexpageref{aurora:\detokenize{module-aurora.atomic}}
\item\relax\sphinxstyleindexentry{aurora.coords}\sphinxstyleindexpageref{aurora:\detokenize{module-aurora.coords}}
\item\relax\sphinxstyleindexentry{aurora.core}\sphinxstyleindexpageref{aurora:\detokenize{module-aurora.core}}
\item\relax\sphinxstyleindexentry{aurora.default\_nml}\sphinxstyleindexpageref{aurora:\detokenize{module-aurora.default_nml}}
\item\relax\sphinxstyleindexentry{aurora.grids\_utils}\sphinxstyleindexpageref{aurora:\detokenize{module-aurora.grids_utils}}
\item\relax\sphinxstyleindexentry{aurora.interp}\sphinxstyleindexpageref{aurora:\detokenize{module-aurora.interp}}
\item\relax\sphinxstyleindexentry{aurora.janev\_smith\_rates}\sphinxstyleindexpageref{aurora:\detokenize{module-aurora.janev_smith_rates}}
\item\relax\sphinxstyleindexentry{aurora.nbi\_neutrals}\sphinxstyleindexpageref{aurora:\detokenize{module-aurora.nbi_neutrals}}
\item\relax\sphinxstyleindexentry{aurora.particle\_conserv}\sphinxstyleindexpageref{aurora:\detokenize{module-aurora.particle_conserv}}
\item\relax\sphinxstyleindexentry{aurora.plot\_tools}\sphinxstyleindexpageref{aurora:\detokenize{module-aurora.plot_tools}}
\item\relax\sphinxstyleindexentry{aurora.radiation}\sphinxstyleindexpageref{aurora:\detokenize{module-aurora.radiation}}
\item\relax\sphinxstyleindexentry{aurora.source\_utils}\sphinxstyleindexpageref{aurora:\detokenize{module-aurora.source_utils}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}