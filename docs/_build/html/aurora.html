

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Aurora modules &mdash; Aurora 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Atomic data" href="atomic_data.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Aurora
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="requirements.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="params.html">Input parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="atomic_data.html">Atomic data</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Aurora modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-aurora.core">aurora.core module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-aurora.atomic">aurora.atomic module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-aurora.adas_files">aurora.adas_files module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-aurora.radiation">aurora.radiation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-aurora.grids_utils">aurora.grids_utils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-aurora.coords">aurora.coords module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-aurora.source_utils">aurora.source_utils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-aurora.plot_tools">aurora.plot_tools module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-aurora.default_nml">aurora.default_nml module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-aurora.interp">aurora.interp module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-aurora.animate">aurora.animate module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-aurora.particle_conserv">aurora.particle_conserv module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-aurora.nbi_neutrals">aurora.nbi_neutrals module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-aurora.janev_smith_rates">aurora.janev_smith_rates module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-aurora">Module contents</a></li>
</ul>
</li>
</ul>

            
          
    <a href="genindex.html">Index</a>
  
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Aurora</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Aurora modules</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/aurora.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="aurora-modules">
<h1>Aurora modules<a class="headerlink" href="#aurora-modules" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-aurora.core">
<span id="aurora-core-module"></span><h2>aurora.core module<a class="headerlink" href="#module-aurora.core" title="Permalink to this headline">¶</a></h2>
<p>This module includes the core class to set up simulations with <a class="reference internal" href="#module-aurora" title="aurora"><code class="xref py py-mod docutils literal notranslate"><span class="pre">aurora</span></code></a>. The <a class="reference internal" href="#aurora.core.aurora_sim" title="aurora.core.aurora_sim"><code class="xref py py-class docutils literal notranslate"><span class="pre">aurora_sim</span></code></a> takes as input a namelist dictionary and a g-file dictionary (and possibly other optional argument) and allows creation of grids, interpolation of atomic rates and other steps before running the forward model.</p>
<dl class="py class">
<dt id="aurora.core.aurora_sim">
<em class="property">class </em><code class="sig-prename descclassname">aurora.core.</code><code class="sig-name descname">aurora_sim</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">namelist</span></em>, <em class="sig-param"><span class="n">geqdsk</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nbi_cxr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/core.html#aurora_sim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.core.aurora_sim" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class to setup and run aurora simulations.</p>
<dl class="py method">
<dt id="aurora.core.aurora_sim.calc_Zeff">
<code class="sig-name descname">calc_Zeff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/core.html#aurora_sim.calc_Zeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.core.aurora_sim.calc_Zeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Zeff from each charge state density, using the result of an Aurora simulation.
The total Zeff change over time and space due to the simulated impurity can be simply obtained by summing
over charge states</p>
<p>Results are stored as an attribute of the simulation object instance.</p>
</dd></dl>

<dl class="py method">
<dt id="aurora.core.aurora_sim.check_conservation">
<code class="sig-name descname">check_conservation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">axs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/core.html#aurora_sim.check_conservation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.core.aurora_sim.check_conservation" title="Permalink to this definition">¶</a></dt>
<dd><p>Check particle conservation for an aurora simulation.</p>
<dl class="simple">
<dt>Args :</dt><dd><dl class="simple">
<dt>plot<span class="classifier">bool, optional</span></dt><dd><p>If True, plot time histories in each particle reservoir and display quality of particle conservation.</p>
</dd>
<dt>axs<span class="classifier">matplotlib.Axes instances, optional</span></dt><dd><p>Axes to pass to <a class="reference internal" href="#aurora.particle_conserv.check_particle_conserv" title="aurora.particle_conserv.check_particle_conserv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">check_particle_conserv()</span></code></a>
These may be the axes returned from a previous call to this function, to overlap
results for different runs.</p>
</dd>
</dl>
</dd>
<dt>Returns :</dt><dd><dl class="simple">
<dt>out<span class="classifier">dict</span></dt><dd><p>Dictionary containing density of particles in each reservoir.</p>
</dd>
<dt>axs<span class="classifier">matplotlib.Axes instances , only returned if plot=True</span></dt><dd><p>New or updated axes returned by <a class="reference internal" href="#aurora.particle_conserv.check_particle_conserv" title="aurora.particle_conserv.check_particle_conserv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">check_particle_conserv()</span></code></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="aurora.core.aurora_sim.get_aurora_kin_profs">
<code class="sig-name descname">get_aurora_kin_profs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">min_T</span><span class="o">=</span><span class="default_value">1.01</span></em>, <em class="sig-param"><span class="n">min_ne</span><span class="o">=</span><span class="default_value">10000000000.0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/core.html#aurora_sim.get_aurora_kin_profs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.core.aurora_sim.get_aurora_kin_profs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get kinetic profiles on radial and time grids.</p>
</dd></dl>

<dl class="py method">
<dt id="aurora.core.aurora_sim.get_par_loss_rate">
<code class="sig-name descname">get_par_loss_rate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">trust_SOL_Ti</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/core.html#aurora_sim.get_par_loss_rate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.core.aurora_sim.get_par_loss_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the parallel loss frequency on the radial and temporal grids [1/s].</p>
<p>trust_SOL_Ti should generally be set to False, unless specific Ti measurements are available
in the SOL.</p>
</dd></dl>

<dl class="py method">
<dt id="aurora.core.aurora_sim.get_time_dept_atomic_rates">
<code class="sig-name descname">get_time_dept_atomic_rates</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/core.html#aurora_sim.get_time_dept_atomic_rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.core.aurora_sim.get_time_dept_atomic_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain time-dependent ionization and recombination rates for a simulation run.
If kinetic profiles are given as time-independent, atomic rates for each time slice
will be set to be the same.</p>
</dd></dl>

<dl class="py method">
<dt id="aurora.core.aurora_sim.interp_kin_prof">
<code class="sig-name descname">interp_kin_prof</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">prof</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/core.html#aurora_sim.interp_kin_prof"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.core.aurora_sim.interp_kin_prof" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate the given kinetic profile on the radial and temporal grids [units of s].
This function extrapolates in the SOL based on input options using the same methods as in STRAHL.</p>
</dd></dl>

<dl class="py method">
<dt id="aurora.core.aurora_sim.run_aurora">
<code class="sig-name descname">run_aurora</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">D_z</span></em>, <em class="sig-param"><span class="n">V_z</span></em>, <em class="sig-param"><span class="n">times_DV</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nz_init</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">alg_opt</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">evolneut</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">use_julia</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/core.html#aurora_sim.run_aurora"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.core.aurora_sim.run_aurora" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a simulation using inputs in the given dictionary and D,v profiles as a function
of space, time and potentially also ionization state. Users may give an initial state of each
ion charge state as an input.</p>
<p>Results can be conveniently visualized with time-slider using</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">aurora</span><span class="o">.</span><span class="n">slider_plot</span><span class="p">(</span><span class="n">rhop</span><span class="p">,</span><span class="n">time</span><span class="p">,</span> <span class="n">nz</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
                   <span class="n">xlabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\rho_p$&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;time [s]&#39;</span><span class="p">,</span>
                   <span class="n">zlabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$n_z$ [cm$^{-3}$]&#39;</span><span class="p">,</span> <span class="n">plot_sum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;Ca$^</span><span class="se">{{</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="se">}}</span><span class="s1">$&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nz_w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>D_z</strong> – arrays, shape of (space,time,nZ) or (space,time) or (space,)
Diffusion and convection coefficients, in units of cm^2/s and cm/s, respectively.
This may be given as a function of (space,time) or (space,nZ, time), where nZ indicates
the number of charge states. If D_z and V_z are found to be have only 2 dimensions,
it is assumed that all charge states should have the same transport coefficients.
If they are only 1-D, it is further assumed that they are time-independent.
Note that it is assumed that D_z and V_z profiles are already on the self.rvol_grid
radial grid.</p></li>
<li><p><strong>V_z</strong> – arrays, shape of (space,time,nZ) or (space,time) or (space,)
Diffusion and convection coefficients, in units of cm^2/s and cm/s, respectively.
This may be given as a function of (space,time) or (space,nZ, time), where nZ indicates
the number of charge states. If D_z and V_z are found to be have only 2 dimensions,
it is assumed that all charge states should have the same transport coefficients.
If they are only 1-D, it is further assumed that they are time-independent.
Note that it is assumed that D_z and V_z profiles are already on the self.rvol_grid
radial grid.</p></li>
<li><p><strong>times_DV</strong> – 1D array, optional
Array of times at which D_z and V_z profiles are given. By Default, this is None,
which implies that D_z and V_z are time independent.</p></li>
<li><p><strong>nz_init</strong> – array, shape of (space, nZ)
Impurity charge states at the initial time of the simulation. If left to None, this is
internally set to an array of 0’s.</p></li>
<li><p><strong>alg_opt</strong> – int, optional
If alg_opt=1, use the finite-volume algorithm proposed by Linder et al. NF 2020.
If alg_opt=1, use the older finite-differences algorithm in the 2018 version of STRAHL.</p></li>
<li><p><strong>evolneut</strong> – bool, optional
If True, evolve neutral impurities based on their D,V coefficients. Default is False, in
which case neutrals are only taken as a source and those that are not ionized immediately after
injection are neglected.
This option is NOT CURRENTLY RECOMMENDED, because this method is still under development/
examination.</p></li>
<li><p><strong>use_julia</strong> – bool, optional
If True, run the Julia pre-compiled version of the code. Run the julia makefile option to set
this up. Default is False (still under development)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array, (nr,nZ,nt)</dt><dd><p>Charge state densities [:math::<cite>cm^{-3}</cite>] over the space and time grids.</p>
</dd>
<dt>N_wall<span class="classifier">array (nt,)</span></dt><dd><p>Number of particles at the wall reservoir over time.</p>
</dd>
<dt>N_div<span class="classifier">array (nt,)</span></dt><dd><p>Number of particles in the divertor reservoir over time.</p>
</dd>
<dt>N_pump<span class="classifier">array (nt,)</span></dt><dd><p>Number of particles in the pump reservoir over time.</p>
</dd>
<dt>N_ret<span class="classifier">array (nt,)</span></dt><dd><p>Number of particles temporarily held in the wall reservoirs.</p>
</dd>
<dt>N_tsu<span class="classifier">array (nt,)</span></dt><dd><p>Edge particle loss [:math::<cite>cm^{-3}</cite>]</p>
</dd>
<dt>N_dsu<span class="classifier">array (nt,)</span></dt><dd><p>Parallel particle loss [:math::<cite>cm^{-3}</cite>]</p>
</dd>
<dt>N_dsul<span class="classifier">array (nt,)</span></dt><dd><p>Parallel particle loss at the limiter [:math::<cite>cm^{-3}</cite>]</p>
</dd>
<dt>rcld_rate<span class="classifier">array (nt,)</span></dt><dd><p>Recycling from the divertor [:math::<cite>s^{-1} cm^{-3}</cite>]</p>
</dd>
<dt>rclw_rate<span class="classifier">array (nt,)</span></dt><dd><p>Recycling from the wall [:math::<cite>s^{-1} cm^{-3}</cite>]</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>nz</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-aurora.atomic">
<span id="aurora-atomic-module"></span><h2>aurora.atomic module<a class="headerlink" href="#module-aurora.atomic" title="Permalink to this headline">¶</a></h2>
<p>Collection of classes and functions for loading, interpolation and processing of atomic data.
Refer also to the adas_files.py script.</p>
<dl class="py class">
<dt id="aurora.atomic.CartesianGrid">
<em class="property">class </em><code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">CartesianGrid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">grids</span></em>, <em class="sig-param"><span class="n">values</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#CartesianGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.CartesianGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Linear multivariate Cartesian grid interpolation in arbitrary dimensions
This is a regular grid with equal spacing.</p>
</dd></dl>

<dl class="py class">
<dt id="aurora.atomic.adas_file">
<em class="property">class </em><code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">adas_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filepath</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#adas_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.adas_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Read ADAS file in ADF11 format over the given density and temperature grids.
Note that such grids vary between files, and the species they refer to may too.</p>
<p>Refer to ADAS documentation for details on each file.</p>
<dl class="py method">
<dt id="aurora.atomic.adas_file.load">
<code class="sig-name descname">load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#adas_file.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.adas_file.load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="aurora.atomic.adas_file.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fig</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#adas_file.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.adas_file.plot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="aurora.atomic.balance">
<code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">balance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">logTe_val</span></em>, <em class="sig-param"><span class="n">cs</span></em>, <em class="sig-param"><span class="n">n0_by_ne</span></em>, <em class="sig-param"><span class="n">logTe_</span></em>, <em class="sig-param"><span class="n">S</span></em>, <em class="sig-param"><span class="n">R</span></em>, <em class="sig-param"><span class="n">cx</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#balance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.balance" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate balance of effective ionization, recombination and charge exchange at a given temperature.</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.atomic.get_adas_file_types">
<code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">get_adas_file_types</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#get_adas_file_types"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.get_adas_file_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain a description of each ADAS file type and its meaning in the context of Aurora.
For background, refer to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Summers</span> <span class="n">et</span> <span class="n">al</span><span class="o">.</span><span class="p">,</span> <span class="s2">&quot;Ionization state, excited populations and emission of impurities</span>
<span class="ow">in</span> <span class="n">dynamic</span> <span class="n">finite</span> <span class="n">density</span> <span class="n">plasmas</span><span class="p">:</span> <span class="n">I</span><span class="o">.</span> <span class="n">The</span> <span class="n">generalized</span> <span class="n">collisional</span><span class="o">-</span><span class="n">radiative</span> <span class="n">model</span> <span class="k">for</span>
<span class="n">light</span> <span class="n">elements</span><span class="s2">&quot;, Plasma Physics and Controlled Fusion, 48:2, 2006</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Dictionary with keys given by the ADAS file types and values giving a description for them.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.atomic.get_atom_data">
<code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">get_atom_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">imp</span></em>, <em class="sig-param"><span class="n">filetypes</span><span class="o">=</span><span class="default_value">['acd', 'scd']</span></em>, <em class="sig-param"><span class="n">filenames</span><span class="o">=</span><span class="default_value">[]</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#get_atom_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.get_atom_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect atomic data for a given impurity from all types of ADAS files available or
for only those requested.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imp</strong> – str
Atomic symbol of impurity ion.</p></li>
<li><p><strong>filetypes</strong> – list or array-like
ADAS file types to be fetched. Default is [“acd”,”scd”] for effective ionization
and recombination rates (excluding CX).</p></li>
<li><p><strong>filenames</strong> – list or array-like, optional
ADAS file names to be used in place of the defaults given by
<code class="xref py py-meth docutils literal notranslate"><span class="pre">adas_file_dict()</span></code>.
If left empty, such defaults are used. Note that the order of filenames must be
the same as the one in the “filetypes” list.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>dict</dt><dd><p>Dictionary containing data for each of the requested files.
Each entry of the dictionary gives log-10 of ne, log-10 of Te and log-10 of the data
as attributes atom_data[key].logNe, atom_data[key].logT, atom_data[key].data</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>atom_data</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.atomic.get_cooling_factors">
<code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">get_cooling_factors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">atom_data</span></em>, <em class="sig-param"><span class="n">logTe_prof</span></em>, <em class="sig-param"><span class="n">fz</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ax</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#get_cooling_factors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.get_cooling_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate cooling coefficients for the given fractional abundances and kinetic profiles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atom_data</strong> – dict
Dictionary containing atomic data as output by <a class="reference internal" href="#aurora.atomic.get_atom_data" title="aurora.atomic.get_atom_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_atom_data()</span></code></a>
for the atomic processes of interest. “prs”,”pls”,”plt” and “prb” are required by this function.</p></li>
<li><p><strong>logTe_prof</strong> – array (nt,nr)
Log-10 of electron temperature profile (in eV)</p></li>
<li><p><strong>fz</strong> – array (nt,nr)
Fractional abundances for all charge states of the ion of “atom_data”</p></li>
<li><p><strong>plot</strong> – bool
If True, plot all radiation components, summed over charge states.</p></li>
<li><p><strong>ax</strong> – matplotlib.Axes instance
If provided, plot results on these axes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array (nt,nr)</dt><dd><p>Line radiation in the SXR range for each charge state</p>
</dd>
<dt>prs<span class="classifier">array (nt,nr)</span></dt><dd><p>Continuum radiation in the SXR range for each charge state</p>
</dd>
<dt>pltt<span class="classifier">array (nt,nr)</span></dt><dd><p>Line radiation (unfiltered) for each charge state.
NB: this corresponds to the ADAS “plt” files. An additional “t” is added to the name to avoid
conflict with the common matplotlib.pyplot short form “plt”</p>
</dd>
<dt>prb<span class="classifier">array (nt,nr)</span></dt><dd><p>Continuum radiation (unfiltered) for each charge state</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pls</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.atomic.get_cs_balance_terms">
<code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">get_cs_balance_terms</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">atom_data</span></em>, <em class="sig-param"><span class="n">ne_cm3</span><span class="o">=</span><span class="default_value">50000000000000.0</span></em>, <em class="sig-param"><span class="n">Te_eV</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">maxTe</span><span class="o">=</span><span class="default_value">10000.0</span></em>, <em class="sig-param"><span class="n">include_cx</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#get_cs_balance_terms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.get_cs_balance_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Get S, R and cx on the same logTe grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atom_data</strong> – dictionary of atomic ADAS files (only acd, scd are required; ccd is
necessary only if include_cx=True</p></li>
<li><p><strong>ne_cm3</strong> – float or array
Electron density in units of cm^-3</p></li>
<li><p><strong>Te_eV</strong> – float or array
Electron temperature in units of eV. If left to None, the Te grid
given in the atomic data is used.</p></li>
<li><p><strong>maxTe</strong> – float
Maximum temperature of interest; only used if Te is left to None.</p></li>
<li><p><strong>include_cx</strong> – bool
If True, obtain charge exchange terms as well.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array (n_Te)</dt><dd><p>log10 Te grid on which atomic rates are given</p>
</dd>
<dt>logS, logR (,logcx): arrays (n_ne,n_Te)</dt><dd><p>atomic rates for effective ionization, radiative+dielectronic
recombination (+ charge exchange, if requested). After exponentiation, all terms
will be in units of s^-1.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>logTe</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.atomic.get_frac_abundances">
<code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">get_frac_abundances</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">atom_data</span></em>, <em class="sig-param"><span class="n">ne_cm3</span></em>, <em class="sig-param"><span class="n">Te_eV</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">n0_by_ne</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">include_cx</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ax</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rho</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rho_lbl</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ls</span><span class="o">=</span><span class="default_value">'-'</span></em>, <em class="sig-param"><span class="n">compute_rates</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#get_frac_abundances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.get_frac_abundances" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate fractional abundances from ionization and recombination equilibrium.
If include_cx=True, radiative recombination and thermal charge exchange are summed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atom_data</strong> – dictionary of atomic ADAS files (only acd, scd are required; ccd is
necessary only if include_cx=True</p></li>
<li><p><strong>ne_cm3</strong> – float or array
Electron density in units of cm^-3</p></li>
<li><p><strong>Te_eV</strong> – float or array, optional
Electron temperature in units of eV. If left to None, the Te grid given in the
atomic data is used.</p></li>
<li><p><strong>n0_by_ne</strong> – float or array, optional
Ratio of background neutral hydrogen to electron density, used if include_cx=True.</p></li>
<li><p><strong>include_cx</strong> – bool
If True, charge exchange with background thermal neutrals is included.</p></li>
<li><p><strong>plot</strong> – bool, optional
Show fractional abundances as a function of ne,Te profiles parameterization.</p></li>
<li><p><strong>ax</strong> – matplotlib.pyplot Axes instance
Axes on which to plot if plot=True. If False, it creates new axes</p></li>
<li><p><strong>rho</strong> – list or array, optional
Vector of radial coordinates on which ne,Te (and possibly n0_by_ne) are given.
This is only used for plotting, if given.</p></li>
<li><p><strong>rho_lbl</strong> – str, optional
Label to be used for rho. If left to None, defaults to a general “rho”.</p></li>
<li><p><strong>ls</strong> – str, optional
Line style for plots. Continuous lines are used by default.</p></li>
<li><p><strong>compute_rates</strong> – bool
If True, compute rate coefficients for ionization/recombination equilibrium on top
of fractional abundances (which should be the same regardless of the method used).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array</dt><dd><p>log10 of electron temperatures as a function of which the fractional abundances and
rate coefficients are given.</p>
</dd>
<dt>fz<span class="classifier">array, (space,nZ)</span></dt><dd><p>Fractional abundances across the same grid used by the input ne,Te values.</p>
</dd>
<dt>rate_coeff<span class="classifier">array, (space, nZ)</span></dt><dd><p>Rate coefficients in units of [s^-1].</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>logTe</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.atomic.gff_mean">
<code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">gff_mean</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Z</span></em>, <em class="sig-param"><span class="n">Te</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#gff_mean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.gff_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Total free-free gaunt factor yielding the total radiated bremsstrahlung power
when multiplying with the result for gff=1.
Data originally from Karzas &amp; Latter, extracted from STRAHL’s atomic_data.f.</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.atomic.impurity_brems">
<code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">impurity_brems</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nz</span></em>, <em class="sig-param"><span class="n">ne</span></em>, <em class="sig-param"><span class="n">Te</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#impurity_brems"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.impurity_brems" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate impurity bremsstrahlung in units of mW/nm/sr/m^3.cm^3.</p>
<p>This may not be very useful, since this contribution is already included in the
continuum radiation component in ADAS files.</p>
<p>This estimate does not have the correct ne-dependence of the Gaunt factor… use with care!</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.atomic.interp_atom_prof">
<code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">interp_atom_prof</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">atom_table</span></em>, <em class="sig-param"><span class="n">x_prof</span></em>, <em class="sig-param"><span class="n">y_prof</span></em>, <em class="sig-param"><span class="n">log_val</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">x_multiply</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#interp_atom_prof"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.interp_atom_prof" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast interpolate atomic data in atom_table onto the x_prof and y_prof profiles.
This function assume that x_prof, y_prof, x,y, table are all base-10 logarithms,
and x_prof, y_prof are equally spaced.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atom_table</strong> – list
List with x,y, table = atom_table, containing atomic data from one of the ADAS files.</p></li>
<li><p><strong>x_prof</strong> – array (nt,nr)
Spatio-temporal profiles of the first coordinate of the ADAS file table (usually
electron density in cm^-3)</p></li>
<li><p><strong>y_prof</strong> – array (nt,nr)
Spatio-temporal profiles of the second coordinate of the ADAS file table (usually
electron temperature in eV)</p></li>
<li><p><strong>log_val</strong> – bool
If True, return natural logarithm of the data</p></li>
<li><p><strong>x_multiply</strong> – bool
If True, multiply output by 10**x_prof.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array (nt,nion,nr)</dt><dd><p>Interpolated atomic data on time,charge state and spatial grid that correspond to the
ion of interest and the spatiotemporal grids of x_prof and y_prof.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>interp_vals</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.atomic.main_ion_brems">
<code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">main_ion_brems</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Zi</span></em>, <em class="sig-param"><span class="n">ni</span></em>, <em class="sig-param"><span class="n">ne</span></em>, <em class="sig-param"><span class="n">Te</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#main_ion_brems"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.main_ion_brems" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate main-ion bremsstrahlung in units of  mW/nm/sr/m^3.cm^3.</p>
<p>It is likely better to calculate this from H/D/T plt files, which will have more accurate
Gaunt factors with the correct density dependence.</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.atomic.null_space">
<code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">null_space</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#null_space"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.null_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Find null space of matrix A</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.atomic.plot_norm_ion_freq">
<code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">plot_norm_ion_freq</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">S_z</span></em>, <em class="sig-param"><span class="n">q_prof</span></em>, <em class="sig-param"><span class="n">R_prof</span></em>, <em class="sig-param"><span class="n">imp_A</span></em>, <em class="sig-param"><span class="n">Ti_prof</span></em>, <em class="sig-param"><span class="n">nz_profs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rhop</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">eps_prof</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#plot_norm_ion_freq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.plot_norm_ion_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare effective ionization rate for each charge state with the
characteristic transit time that a non-trapped and trapped impurity ion takes
to travel a parallel distance L = q R.</p>
<p>If the normalized ionization rate is less than 1, then flux surface averaging of
background asymmetries (e.g. from edge or beam neutrals) can be considered in a
“flux-surface-averaged” sense; otherwise, local effects (i.e. not flux-surface-averaged)
may be too important to ignore.</p>
<p>This function is inspired by Dux et al. NF 2020. Note that in this paper the ionization
rate averaged over all charge state densities is considered. This function avoids the
averaging over charge states, unless these are provided as an input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>S_z</strong> – array (r,cs) [s^-1]
Effective ionization rates for each charge state as a function of radius.
Note that, for convenience within aurora, cs includes the neutral stage.</p></li>
<li><p><strong>q_prof</strong> – array (r,)
Radial profile of safety factor</p></li>
<li><p><strong>R_prof</strong> – array (r,) or float [m]
Radial profile of major radius, either given as an average of HFS and LFS, or also
simply as a scalar (major radius on axis)</p></li>
<li><p><strong>imp_A</strong> – float [amu]
Atomic mass number, i.e. number of protons + neutrons (e.g. 2 for D)</p></li>
<li><p><strong>Ti_prof</strong> – array (r,)
Radial profile of ion temperature [eV]</p></li>
<li><p><strong>nz_profs</strong> – array (r,cs), optional
Radial profile for each charge state. If provided, calculate average normalized
ionization rate over all charge states.</p></li>
<li><p><strong>rhop</strong> – array (r,), optional
Sqrt of poloidal flux radial grid. This is used only for (optional) plotting.</p></li>
<li><p><strong>plot</strong> – bool, optional
If True, plot results.</p></li>
<li><p><strong>eps_prof</strong> – array (r,), optional
Radial profile of inverse aspect ratio, i.e. r/R, only used if plotting is requested.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array (r,cs) or (r,)</dt><dd><p>Normalized ionization rate. If nz_profs is given as an input, this is an average over
all charge state; otherwise, it is given for each charge state.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>nu_ioniz_star</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.atomic.plot_relax_time">
<code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">plot_relax_time</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">logTe</span></em>, <em class="sig-param"><span class="n">rate_coeff</span></em>, <em class="sig-param"><span class="n">ax</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#plot_relax_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.plot_relax_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot relaxation time of the ionization equilibrium corresponding
to the inverse of the given rate coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logTe</strong> – array (nr,)
log-10 of Te [eV], on an arbitrary grid (same as other arguments, but not
necessarily radial)</p></li>
<li><p><strong>rate_coeff</strong> – array (nr,)
Rate coefficients from ionization balance. See <a class="reference internal" href="#aurora.atomic.get_frac_abundances" title="aurora.atomic.get_frac_abundances"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_frac_abundances()</span></code></a>
to obtain these via the “compute_rates” argument.
N.B.: these rate coefficients will depend also on electron density, which does affect
relaxation times.</p></li>
<li><p><strong>ax</strong> – matplotlib axes instance, optional
If provided, plot relaxation times on these axes.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.atomic.read_adf15">
<code class="sig-prename descclassname">aurora.atomic.</code><code class="sig-name descname">read_adf15</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">Te_max</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ne_max</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ax</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">plot_log</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">plot_3d</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">recomb</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">pec_plot_min</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pec_plot_max</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">plot_lines</span><span class="o">=</span><span class="default_value">[]</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/atomic.html#read_adf15"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.atomic.read_adf15" title="Permalink to this definition">¶</a></dt>
<dd><p>Read photon emissivity coefficients from an ADF15 file.</p>
<p>Returns a dictionary whose keys are the wavelengths of the lines in
angstroms. The value is an interp2d instance that will evaluate the PEC at
a desired dens, temp.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> – str
Path to adf15 file to read.</p></li>
<li><p><strong>order</strong> – int, opt
Parameter to control the order of interpolation.</p></li>
<li><p><strong>recomb</strong> – bool, opt
If True, fetch recombination contributions to available lines. If False,
fetch only ionization contributions.</p></li>
<li><p><strong>plot PEC data</strong> (<em>To</em>) – </p></li>
<li><p><strong>plot_lines</strong> – list
List of lines whose PEC data should be displayed. Lines should be identified
by their wavelengths. The list of available wavelengths in a given file can be retrieved
by first running this function ones, checking dictionary keys, and then requesting a
plot of one (or more) of them.</p></li>
<li><p><strong>plot_log</strong> – bool
When plotting, set a log scale</p></li>
<li><p><strong>plot_3d</strong> – bool
Display PEC data as a 3D plot rather than a 2D one.</p></li>
<li><p><strong>pec_plot_min</strong> – float
Minimum value of PEC to visualize in a plot</p></li>
<li><p><strong>pec_plot_max</strong> – float
Maximum value of PEC to visualize in a plot</p></li>
<li><p><strong>ax</strong> – matplotlib axes instance
If not None, plot on this set of axes</p></li>
<li><p><strong>Te_max</strong> – float
Maximum Te value to plot when len(plot_lines)&gt;1</p></li>
<li><p><strong>ne_max</strong> – float
Maximum ne value to plot when len(plot_lines)&gt;1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>dict</dt><dd><p>Dictionary containing interpolation functions for each of the available lines of the
indicated type (ionization or recombination). Each interpolation function takes as arguments
the log-10 of ne and Te.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pec_dict</p>
</dd>
</dl>
<dl class="simple">
<dt>MWE:</dt><dd><p>path=’/home/sciortino/atomlib/atomdat_master/adf15/h/pju#h0.dat’
pec = read_adf15(path, recomb=False)
pec = read_adf15(path, plot_lines=[list(pec.keys())[0]], recomb=False)</p>
</dd>
</dl>
<p>This function should work with PEC files produced via adas810 or adas218.</p>
</dd></dl>

</div>
<div class="section" id="module-aurora.adas_files">
<span id="aurora-adas-files-module"></span><h2>aurora.adas_files module<a class="headerlink" href="#module-aurora.adas_files" title="Permalink to this headline">¶</a></h2>
<p>Functions to provide default ADAS files for Aurora modelling, including capabilities to fetch
these files remotely from the OPEN-ADAS website.</p>
<dl class="py function">
<dt id="aurora.adas_files.adas_files_dict">
<code class="sig-prename descclassname">aurora.adas_files.</code><code class="sig-name descname">adas_files_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/adas_files.html#adas_files_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.adas_files.adas_files_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Selections for ADAS files for Aurora runs and radiation calculations.
This function can be called to fetch a set of default files, which can then be modified (e.g. to
use a new file for a specific SXR filter) before running a calculation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>dict</dt><dd><p>Dictionary with keys equal to the atomic symbols of many of the most common ions of
interest in fusion research. For each ion, a sub-dictionary contains recommended file
names for the relevant ADAS data types. Not all files types are available for all ions.
Files types are usually a subset of
‘acd’,’scd’,’prb’,’plt’,’ccd’,’prc’,’pls’,’prs’,’fis’,’brs’,’pbs’,prc’
Refer to <a class="reference internal" href="#aurora.atomic.get_adas_file_types" title="aurora.atomic.get_adas_file_types"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_adas_file_types()</span></code></a> for a description of the meaning of
each file.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>files</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.adas_files.fetch_adf11_file">
<code class="sig-prename descclassname">aurora.adas_files.</code><code class="sig-name descname">fetch_adf11_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/adas_files.html#fetch_adf11_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.adas_files.fetch_adf11_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Download ADF11 file from the OPEN-ADAS website and store it in the ‘adas_data’
directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> – str
Name of ADF11 file to be downloaded, e.g. ‘plt89_ar.dat’.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.adas_files.get_adas_file_loc">
<code class="sig-prename descclassname">aurora.adas_files.</code><code class="sig-name descname">get_adas_file_loc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/adas_files.html#get_adas_file_loc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.adas_files.get_adas_file_loc" title="Permalink to this definition">¶</a></dt>
<dd><p>Find location of requested atomic data file for the indicated ion.
The search proceeds with the following attempts, in this order:</p>
<ol class="arabic simple">
<li><p>If the file is available in Aurora/adas_data/adf11, always use this data.</p></li>
<li><p>If the environmental variable “AURORA_ADAS_DIR” is defined, attempt to find the file there and copy it to Aurora/adas_data/adf11.</p></li>
<li><p>Attempt to fetch the file remotely via open.adas.ac.uk and save it in Aurora/adas_data/adf11/.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> – str
Name of the ADAS ADF11 file of interest, e.g. ‘plt89_ar.dat’</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>str</dt><dd><p>Full path to the requested file.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>file_loc</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-aurora.radiation">
<span id="aurora-radiation-module"></span><h2>aurora.radiation module<a class="headerlink" href="#module-aurora.radiation" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="aurora.radiation.adf04_files">
<code class="sig-prename descclassname">aurora.radiation.</code><code class="sig-name descname">adf04_files</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/radiation.html#adf04_files"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.radiation.adf04_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Collection of trust-worthy ADAS ADF04 files.
This function will be moved and expanded in ColRadPy in the near future.</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.radiation.compute_rad">
<code class="sig-prename descclassname">aurora.radiation.</code><code class="sig-name descname">compute_rad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">imp</span></em>, <em class="sig-param"><span class="n">nz</span></em>, <em class="sig-param"><span class="n">ne</span></em>, <em class="sig-param"><span class="n">Te</span></em>, <em class="sig-param"><span class="n">n0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Ti</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ni</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">main_ion_name</span><span class="o">=</span><span class="default_value">'D'</span></em>, <em class="sig-param"><span class="n">adas_files</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">prad_flag</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">thermal_cx_rad_flag</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">spectral_brem_flag</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">sxr_flag</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">main_ion_brem_flag</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/radiation.html#compute_rad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.radiation.compute_rad" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate radiation terms corresponding to a simulation result. The nz,ne,Te,n0,Ti,ni arrays
are normally assumed to be given as a function of (time,nZ,space), but time and space may
be substituted by other coordinates (e.g. R,Z)</p>
<p>Result can be conveniently plotted with a time-slider using, for example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">zmax</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># number of charge states (including neutrals)</span>
<span class="n">rad</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;impurity_radiation&#39;</span><span class="p">][:,:</span><span class="n">zmax</span><span class="p">,:]</span>   <span class="c1"># no fully-stripped line radiation</span>
<span class="n">aurora</span><span class="o">.</span><span class="n">slider_plot</span><span class="p">(</span><span class="n">rhop</span><span class="p">,</span><span class="n">time</span><span class="p">,</span> <span class="n">rad</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="mf">1e6</span><span class="p">,</span>
    <span class="n">xlabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\rho_p$&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;time [s]&#39;</span><span class="p">,</span>
    <span class="n">zlabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$P_</span><span class="si">{rad}</span><span class="s1">$ [$MW$]&#39;</span><span class="p">,</span>
    <span class="n">plot_sum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;Ca$^</span><span class="se">{{</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="se">}}</span><span class="s1">$&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nz_w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
</pre></div>
</div>
<p>All radiation outputs are given in <span class="math notranslate nohighlight">\(W cm^{-3}\)</span>, consistently with units of <span class="math notranslate nohighlight">\(cm^{-3}\)</span>
given for inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imp</strong> – str
Impurity symbol, e.g. Ca, F, W</p></li>
<li><p><strong>nz</strong> – array (time, nZ, space) [<span class="math notranslate nohighlight">\(cm^{-3}\)</span>]
Dictionary with impurity density result, as given by <code class="xref py py-func docutils literal notranslate"><span class="pre">run_aurora()</span></code> method.</p></li>
<li><p><strong>ne</strong> – array (time,space) [<span class="math notranslate nohighlight">\(cm^{-3}\)</span>]
Electron density on the output grids.</p></li>
<li><p><strong>Te</strong> – array (time,space) [eV]
Electron temperature on the output grids.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>n0</strong> – array(time,space), optional [<span class="math notranslate nohighlight">\(cm^{-3}\)</span>]
Background neutral density (assumed of hydrogen-isotopes).
This is only used if thermal_cx_rad_flag=True.</p></li>
<li><p><strong>Ti</strong> – array (time,space) [eV]
Main ion temperature (assumed of hydrogen-isotopes). This is only used
if thermal_cx_rad_flag=True. If not set, Ti is taken equal to Te.</p></li>
<li><p><strong>ni</strong> – array (time,space), optional [<span class="math notranslate nohighlight">\(cm^{-3}\)</span>]
Main ion density. This is used if thermal_cx_rad_flag=True and/or
main_ion_brem_flag=True. If not set, ni is taken to be equal to ne, subtracting
the impurity density x Z for each charge state.</p></li>
<li><p><strong>main_ion_name</strong> – str, optional
Atomic symbol of main ion species. Default is ‘D’.
This is only used if main_ion_brem_flag=True.</p></li>
<li><p><strong>adas_files</strong> – dict
Dictionary containing ADAS file names for radiation calculations, possibly including keys
“plt”,”prb”,”prc”,”pls”,”prs”,”pbs”,”brs”
Any file names that are needed and not provided will be searched in the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">adas_files_dict()</span></code> dictionary.</p></li>
<li><p><strong>prad_flag</strong> – bool, optional
If True, total radiation is computed (for each charge state and their sum)</p></li>
<li><p><strong>thermal_cx_rad_flag</strong> – bool, optional
If True, thermal charge exchange radiation is computed.</p></li>
<li><p><strong>spectral_brem_flag</strong> – bool, optional
If True, spectral bremstrahlung is computed (based on available ‘brs’ ADAS file)</p></li>
<li><p><strong>sxr_flag</strong> – bool, optional
If True, soft x-ray radiation is computed (for the given ‘pls’,’prs’ ADAS files)</p></li>
<li><p><strong>main_ion_brem_flag</strong> – bool, optional
If True, main ion bremstrahlung is computed.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>dict</dt><dd><p>Dictionary containing radiation terms, depending on the activated flags.
The structure of the “res” dictionary is as follows.</p>
</dd>
</dl>
<p>If prad_flag=True,</p>
<dl class="simple">
<dt>res[‘line_rad’]<span class="classifier">array (nt,nZ,nr)- from ADAS “plt” files</span></dt><dd><p>Excitation-driven line radiation for each impurity charge state.</p>
</dd>
<dt>res[‘cont_rad’]<span class="classifier">array (nt,nZ,nr)- from ADAS “prb” files</span></dt><dd><p>Continuum and line power driven by recombination and bremsstrahlung for impurity ions.</p>
</dd>
<dt>res[‘imp_brems’]<span class="classifier">array (nt,nr)- analytic formula.</span></dt><dd><p>Bremsstrahlung produced by electron scarrering at fully ionized impurity
This is only an approximate calculation and is more accurately accounted for in the
‘cont_rad’ component.</p>
</dd>
<dt>res[‘thermal_cx_cont_rad’]<span class="classifier">array (nt,nZ,nr)- from ADAS “prc” files</span></dt><dd><p>Radiation deriving from charge transfer from thermal neutral hydrogen to impurity ions.
Returned only if thermal_cx_rad_flag=True.</p>
</dd>
<dt>res[‘tot’]<span class="classifier">array (nt,nZ,nr)</span></dt><dd><p>Total unfilted radiation, summed over all charge states, given by the sum of all known
radiation components.</p>
</dd>
</dl>
<p>If main_ion_brem_flag=True, res[‘main_ion_brems’] is additionally computed and added to
res[‘tot’] (see below).</p>
<p>If sxr_flag=True,</p>
<dl class="simple">
<dt>res[‘sxr_line_rad’]<span class="classifier">array (nt,nZ,nr)- from ADAS “pls” files</span></dt><dd><p>Excitation-driven line radiation for each impurity charge state in the SXR range.</p>
</dd>
<dt>res[‘sxr_cont_rad’]<span class="classifier">array (nt,nZ,nr)- from ADAS “prs” files</span></dt><dd><p>Continuum and line power driven by recombination and bremsstrahlung for impurity ions
in the SXR range.</p>
</dd>
<dt>res[‘sxr_imp_brems’]<span class="classifier">array (nt,nZ,nr)- from ADAS “pbs” files</span></dt><dd><p>Bremsstrahlung produced by electron scarrering at fully ionized impurity in the SXR range.</p>
</dd>
<dt>res[‘sxr_tot’]<span class="classifier">array (nt,nZ,nr)</span></dt><dd><p>Total radiation in the SXR range, summed over all charge states, given by the sum of all known
radiation components in the SXR range.</p>
</dd>
</dl>
<p>If main_ion_brem_flag=True, res[‘sxr_main_ion_brems’] is additionally computed and added to
res[‘sxr_tot’] (see below).</p>
<p>If spectral_brem_flag,</p>
<dl class="simple">
<dt>res[‘spectral_imp_brems’]<span class="classifier">array (nt,nZ,nr) – from ADAS “brs” files</span></dt><dd><p>Bremsstrahlung at a specific wavelength, depending on provided “brs” file.</p>
</dd>
</dl>
<p>If main_ion_brem_flag=True, res[‘main_ion_spectral_brems’] is also computed (see below).</p>
<p>If main_ion_brem_flag,</p>
<dl class="simple">
<dt>res[‘main_ion_brems’]<span class="classifier">array (nt,nr)</span></dt><dd><p>Bremsstrahlung from main (background) ions. This is only computed if prad_flag=True and
is automatically added to the res[‘tot’] array to account for all terms.</p>
</dd>
<dt>res[‘main_ion_spectral_brems’]<span class="classifier">array (nt,nr)</span></dt><dd><p>Bremsstrahlung from main (background) ions at a specific wavelength. This is only computed
if spectral_brem_flag=True too.</p>
</dd>
<dt>res[‘sxr_main_ion_brems’]<span class="classifier">array (nt,nZ,nr)</span></dt><dd><p>Bremsstrahlung from main (background) ions in the SXR range. This is only computed if
sxr_flag=True and is automatically added to res[‘sxr_tot’].</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>res</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.radiation.get_pec_prof">
<code class="sig-prename descclassname">aurora.radiation.</code><code class="sig-name descname">get_pec_prof</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ion</span></em>, <em class="sig-param"><span class="n">cs</span></em>, <em class="sig-param"><span class="n">rhop</span></em>, <em class="sig-param"><span class="n">ne_cm3</span></em>, <em class="sig-param"><span class="n">Te_eV</span></em>, <em class="sig-param"><span class="n">lam_nm</span><span class="o">=</span><span class="default_value">1.8705</span></em>, <em class="sig-param"><span class="n">lam_width_nm</span><span class="o">=</span><span class="default_value">0.002</span></em>, <em class="sig-param"><span class="n">meta_idxs</span><span class="o">=</span><span class="default_value">[0]</span></em>, <em class="sig-param"><span class="n">adf04_repo</span><span class="o">=</span><span class="default_value">'/home/sciortino/adf04_files/ca/ca_adf04_adas/'</span></em>, <em class="sig-param"><span class="n">pec_threshold</span><span class="o">=</span><span class="default_value">1e-20</span></em>, <em class="sig-param"><span class="n">phot2energy</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/radiation.html#get_pec_prof"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.radiation.get_pec_prof" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute radial profile for Photon Emissivity Coefficients (PEC) for lines within the chosen
wavelength range using the ColRadPy package. This is an alternative to the option of using
the <a href="#id1"><span class="problematic" id="id2">:py:method:`~atomic.read_adf15`</span></a> function to read PEC data from an ADAS ADF-15 file and
interpolate results on ne,Te grids.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ion</strong> – str
Ion atomic symbol</p></li>
<li><p><strong>cs</strong> – str
Charge state, given in format like ‘Ca18+’</p></li>
<li><p><strong>rhop</strong> – array (nr,)
Srt of normalized poloidal flux radial array</p></li>
<li><p><strong>ne_cm3</strong> – array (nr,)
Electron density in <span class="math notranslate nohighlight">\(cm^{-3}\)</span> units</p></li>
<li><p><strong>Te_eV</strong> – array (nr,)
Electron temperature in eV units</p></li>
<li><p><strong>lam_nm</strong> – float
Center of the wavelength region of interest [nm]</p></li>
<li><p><strong>lam_width_nm</strong> – float
Width of the wavelength region of interest [nm]</p></li>
<li><p><strong>meta_idxs</strong> – list of integers
List of levels in ADF04 file to be treated as metastable states.</p></li>
<li><p><strong>adf04_repo</strong> – str
Location where ADF04 file from :py:method:adf04_files() should be fetched.</p></li>
<li><p><strong>prec_threshold</strong> – float
Minimum value of PECs to be considered, in <span class="math notranslate nohighlight">\(photons \cdot cm^3/s\)</span></p></li>
<li><p><strong>phot2energy</strong> – bool
If True, results are converted from <span class="math notranslate nohighlight">\(photons \cdot cm^3/s\)</span> to <span class="math notranslate nohighlight">\(W.cm^3\)</span></p></li>
<li><p><strong>plot</strong> – bool
If True, plot lines profiles and total</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array (nr,)</dt><dd><p>Radial profile of PEC intensity, in units of <span class="math notranslate nohighlight">\(photons \cdot cm^3/s\)</span> (if phot2energy=False) or
<span class="math notranslate nohighlight">\(W \cdot cm^3\)</span> depending (if phot2energy=True).</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pec_tot_prof</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.radiation.plot_radiation_profs">
<code class="sig-prename descclassname">aurora.radiation.</code><code class="sig-name descname">plot_radiation_profs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">imp</span></em>, <em class="sig-param"><span class="n">nz_prof</span></em>, <em class="sig-param"><span class="n">logne_prof</span></em>, <em class="sig-param"><span class="n">logTe_prof</span></em>, <em class="sig-param"><span class="n">xvar_prof</span></em>, <em class="sig-param"><span class="n">xvar_label</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">atom_data</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/radiation.html#plot_radiation_profs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.radiation.plot_radiation_profs" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute profiles of predicted radiation, both SXR-filtered and unfiltered.
This function offers a simplified interface to radiation calculation with respect to
<a class="reference internal" href="#aurora.radiation.compute_rad" title="aurora.radiation.compute_rad"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_rad()</span></code></a>, which is more complete.</p>
<p>This function can be used to plot radial profiles (setting xvar_prof to a radial grid)
or profiles as a function of any variable on which the logne_prof and logTe_prof
may depend.</p>
<p>The variable “nz_prof” may be a full description of impurity charge state densities
(e.g. the output of aurora), or profiles of fractional abundances from ionization equilibrium.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imp</strong> – str, optional
Impurity ion atomic symbol.</p></li>
<li><p><strong>nz_prof</strong> – array (TODO for docs: check dimensions)
Impurity charge state densities</p></li>
<li><p><strong>logne_prof</strong> – array (TODO for docs: check dimensions)
Electron density profiles in <span class="math notranslate nohighlight">\(cm^{-3}\)</span></p></li>
<li><p><strong>logTe_prof</strong> – array (TODO for docs: check dimensions)
Electron temperature profiles in eV</p></li>
<li><p><strong>xvar_prof</strong> – array (TODO for docs: check dimensions)
Profiles of a variable of interest, on the same grid as kinetic profiles.</p></li>
<li><p><strong>xvar_label</strong> – str, optional
Label for x-axis.</p></li>
<li><p><strong>atom_data</strong> – dict, optional
Dictionary containing atomic data as output by <a class="reference internal" href="#aurora.atomic.get_atom_data" title="aurora.atomic.get_atom_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_atom_data()</span></code></a>
for the atomic processes of interest. “prs”,”pls”,”plt” and “prb” are required by this function.
If not provided, this function loads these files internally.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array (TODO for docs: check dimensions)</dt><dd><p>SXR line radiation.</p>
</dd>
<dt>prs<span class="classifier">array (TODO for docs: check dimensions)</span></dt><dd><p>SXR continuum radiation.</p>
</dd>
<dt>pltt<span class="classifier">array (TODO for docs: check dimensions)</span></dt><dd><p>Unfiltered line radiation.</p>
</dd>
<dt>prb<span class="classifier">array (TODO for docs: check dimensions)</span></dt><dd><p>Unfiltered continuum radiation.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pls</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.radiation.radiation_model">
<code class="sig-prename descclassname">aurora.radiation.</code><code class="sig-name descname">radiation_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">imp</span></em>, <em class="sig-param"><span class="n">rhop</span></em>, <em class="sig-param"><span class="n">ne_cm3</span></em>, <em class="sig-param"><span class="n">Te_eV</span></em>, <em class="sig-param"><span class="n">vol</span></em>, <em class="sig-param"><span class="n">adas_files</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">n0_cm3</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Ti_eV</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nz_cm3</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">frac</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/radiation.html#radiation_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.radiation.radiation_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Model radiation from a fixed-impurity-fraction model or from detailed impurity density
profiles for the chosen ion. This method acts as a wrapper for :py:method:compute_rad(),
calculating radiation terms over the radius and integrated over the plasma cross section.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imp</strong> – str (nr,)
Impurity ion symbol, e.g. W</p></li>
<li><p><strong>rhop</strong> – array (nr,)
Sqrt of normalized poloidal flux array from the axis outwards</p></li>
<li><p><strong>ne_cm3</strong> – array (nr,)
Electron density in <span class="math notranslate nohighlight">\(cm^{-3}\)</span> units.</p></li>
<li><p><strong>Te_eV</strong> – array (nr,)
Electron temperature in eV</p></li>
<li><p><strong>vol</strong> – array (nr,)
Volume of each flux surface in <span class="math notranslate nohighlight">\(m^3\)</span>. Note the units! We use <span class="math notranslate nohighlight">\(m^3\)</span> here
rather than <span class="math notranslate nohighlight">\(cm^3\)</span> because it is more common to work with <span class="math notranslate nohighlight">\(m^3\)</span> for
flux surface volumes of fusion devices.</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>adas_files</strong> – dict
Dictionary containing ADAS file names for forward modeling and/or radiation calculations.
Possibly useful keys include
“scd”,”acd”,”ccd”,”plt”,”prb”,”prc”,”pls”,”prs”,”pbs”,”brs”
Any file names that are needed and not provided will be searched in the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">adas_files_dict()</span></code> dictionary.</p></li>
<li><p><strong>n0_cm3</strong> – array (nr,), optional
Background ion density (H,D or T). If provided, charge exchange (CX)
recombination is included in the calculation of charge state fractional
abundances.</p></li>
<li><p><strong>Ti_eV</strong> – array (nr,), optional
Background ion density (H,D or T). This is only used if CX recombination is
requested, i.e. if n0_cm3 is not None. If not given, Ti is set equal to Te.</p></li>
<li><p><strong>nz_cm3</strong> – array (nr,nz), optional
Impurity charge state densities in <span class="math notranslate nohighlight">\(cm^{-3}\)</span> units. Fractional abundancies can
alternatively be specified via the :param:frac parameter for a constant-fraction
impurity model across the radius. If provided, nz_cm3 is used.</p></li>
<li><p><strong>frac</strong> – float, optional
Fractional abundance, with respect to ne, of the chosen impurity.
The same fraction is assumed across the radial profile. If left to None,
nz_cm3 must be given.</p></li>
<li><p><strong>plot</strong> – bool, optional
If True, plot a number of diagnostic figures.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>dict</dt><dd><p>Dictionary containing results of radiation model.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>res</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-aurora.grids_utils">
<span id="aurora-grids-utils-module"></span><h2>aurora.grids_utils module<a class="headerlink" href="#module-aurora.grids_utils" title="Permalink to this headline">¶</a></h2>
<p>Methods to create radial and time grids for aurora simulations.</p>
<dl class="py function">
<dt id="aurora.grids_utils.create_aurora_time_grid">
<code class="sig-prename descclassname">aurora.grids_utils.</code><code class="sig-name descname">create_aurora_time_grid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">timing</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/grids_utils.html#create_aurora_time_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.grids_utils.create_aurora_time_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Create time grid for simulations using a Fortran routine for definitions.
The same functionality is offered by <code class="xref py py-func docutils literal notranslate"><span class="pre">create_time_grid()</span></code>, which however
is written in Python. This method is legacy code; it is recommended to use the other.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timing</strong> – dict
Dictionary containing
timing[‘times’],timing[‘dt_start’],timing[‘steps_per_cycle’],timing[‘dt_increase’]
which define the start times to change dt values at, the dt values to start with,
the number of time steps before increasing the dt by dt_increase.
The last value in each of these arrays is used for sawteeth, whenever these are
modelled, or else are ignored. This is the same time grid definition as used in STRAHL.</p></li>
<li><p><strong>plot</strong> – bool, optional
If True, display the created time grid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array</dt><dd><p>Computational time grid corresponding to <cite>timing</cite> input.</p>
</dd>
<dt>save<span class="classifier">array</span></dt><dd><p>Array of zeros and ones, where ones indicate that the time step will be stored in memory
in aurora simulations. Points corresponding to zeros will not be returned to spare memory.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>time</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.grids_utils.create_radial_grid">
<code class="sig-prename descclassname">aurora.grids_utils.</code><code class="sig-name descname">create_radial_grid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">namelist</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/grids_utils.html#create_radial_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.grids_utils.create_radial_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Create radial grid for aurora based on K, dr_0, dr_1, rvol_lcfs and bound_sep parameters.
The lim_sep parameters is additionally used if plotting is requested.</p>
<p>Radial mesh points are set to be equidistant in the coordinate <span class="math notranslate nohighlight">\(\rho\)</span>, with</p>
<div class="math notranslate nohighlight">
\[\rho = \frac{r}{\Delta r_{centre}} + \frac{r_{edge}}{k+1} \left(\frac{1}{\Delta r_{edge}}- \frac{1}{\Delta r_{centre}} \right) \left(\frac{r}{r_{edge}} \right)^{k+1}\]</div>
<p>The corresponding radial step size is</p>
<div class="math notranslate nohighlight">
\[\Delta r = \left[\frac{1}{\Delta r_{centre}} + \left(\frac{1}{\Delta r_{edge}} - \frac{1}{\Delta r_{centre}} \right) \left(\frac{r}{r_{edge}}\right)^k \right]^{-1}\]</div>
<p>See the STRAHL manual for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>namelist</strong> – dict
Dictionary containing aurora namelist. This function uses the K, dr_0, dr_1, rvol_lcfs
and bound_sep parameters. Additionally, lim_sep is used if plotting is requested.</p></li>
<li><p><strong>plot</strong> – bool, optional
If True, plot the radial grid spacing vs. radial location.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array</dt><dd><p>Volume-normalized grid used for aurora simulations.</p>
</dd>
<dt>pro<span class="classifier">array</span></dt><dd><p>Normalized first derivatives of the radial grid, defined as
pro = (drho/dr)/(2 d_rho) = rho’/(2 d_rho)</p>
</dd>
<dt>qpr<span class="classifier">array</span></dt><dd><p>Normalized second derivatives of the radial grid, defined as
qpr = (d^2 rho/dr^2)/(2 d_rho) = rho’’/(2 d_rho)</p>
</dd>
<dt>prox_param<span class="classifier">float</span></dt><dd><p>Grid parameter used for perpendicular loss rate at the last radial grid point.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>rvol_grid</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.grids_utils.create_time_grid">
<code class="sig-prename descclassname">aurora.grids_utils.</code><code class="sig-name descname">create_time_grid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">timing</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/grids_utils.html#create_time_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.grids_utils.create_time_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Create time grid for simulations using the Fortran implementation
of the time grid generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timing</strong> – dict
Dictionary containing timing elements: ‘times’, ‘dt_start’, ‘steps_per_cycle’,’dt_increase’
As in STRAHL, the last element in each of these arrays refers to sawtooth events.</p></li>
<li><p><strong>plot</strong> – bool
If True, plot time grid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array</dt><dd><p>Computational time grid corresponding to :param:timing input.</p>
</dd>
<dt>save<span class="classifier">array</span></dt><dd><p>Array of zeros and ones, where ones indicate that the time step will be stored in memory
in aurora simulations. Points corresponding to zeros will not be returned to spare memory.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>time</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.grids_utils.create_time_grid_new">
<code class="sig-prename descclassname">aurora.grids_utils.</code><code class="sig-name descname">create_time_grid_new</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">timing</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/grids_utils.html#create_time_grid_new"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.grids_utils.create_time_grid_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Define time base for Aurora based on user inputs
This function reproduces the functionality of STRAHL’s time_steps.f
Refer to the STRAHL manual for definitions of the time grid</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – int
Number of elements in time definition arrays</p></li>
<li><p><strong>t</strong> – array
Time vector of the time base changes</p></li>
<li><p><strong>dtstart</strong> – array
dt value at the start of a cycle</p></li>
<li><p><strong>itz</strong> – array
cycle length, i.e. number of time steps before increasing dt</p></li>
<li><p><strong>tinc</strong> – factor by which time steps should be increasing within a cycle</p></li>
<li><p><strong>verbose</strong> – bool
If Trueprint to terminal a few extra info</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array</dt><dd><p>Times in the time base [s]</p>
</dd>
<dt>i_save<span class="classifier">array</span></dt><dd><p>Array of 0,1 values indicating at which times internal arrays should be stored/returned.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>t_vals</p>
</dd>
</dl>
<p>~~~~~~~~~~~ THIS ISN’T FUNCTIONAL YET! ~~~~~~~~~~~~</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.grids_utils.estimate_boundary_distance">
<code class="sig-prename descclassname">aurora.grids_utils.</code><code class="sig-name descname">estimate_boundary_distance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shot</span></em>, <em class="sig-param"><span class="n">device</span></em>, <em class="sig-param"><span class="n">time_ms</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/grids_utils.html#estimate_boundary_distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.grids_utils.estimate_boundary_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain a simple estimate for the distance between the LCFS and the wall boundary.
This requires access to the A_EQDSK on the EFIT01 tree on MDS+. Users who may find that this call
does not work for their device may try to adapt the OMFITmdsValue TDI string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shot</strong> – int
Discharge/experiment number</p></li>
<li><p><strong>device</strong> – str
Name of device, e.g. ‘C-Mod’, ‘DIII-D’, etc.</p></li>
<li><p><strong>time_ms</strong> – int or float
Time at which results for the outer gap should be taken.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>float</dt><dd><p>Estimate for the distance between the wall boundary and the separatrix [cm]</p>
</dd>
<dt>lim_sep<span class="classifier">float</span></dt><dd><p>Estimate for the distance between the limiter and the separatrix [cm]. This is (quite arbitrarily)
taken to be 2/3 of the bound_sep distance.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bound_sep</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.grids_utils.estimate_clen">
<code class="sig-prename descclassname">aurora.grids_utils.</code><code class="sig-name descname">estimate_clen</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">geqdsk</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/grids_utils.html#estimate_clen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.grids_utils.estimate_clen" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate average connection length in the open SOL and in the limiter shadow
NB: these are just rough numbers!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>geqdsk</strong> – dict
EFIT g-EQDSK as processed by the omfit_eqdsk package.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>float</dt><dd><p>Estimate of the connection length to the divertor</p>
</dd>
<dt>clen_limiter<span class="classifier">float</span></dt><dd><p>Estimate of the connection length to the limiter</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>clen_divertor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.grids_utils.get_HFS_LFS">
<code class="sig-prename descclassname">aurora.grids_utils.</code><code class="sig-name descname">get_HFS_LFS</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">geqdsk</span></em>, <em class="sig-param"><span class="n">rho_pol</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/grids_utils.html#get_HFS_LFS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.grids_utils.get_HFS_LFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Get high-field-side (HFS) and low-field-side (LFS) major radii from the g-EQDSK data.
This is useful to define the rvol grid outside of the LCFS.
See the <code class="xref py py-func docutils literal notranslate"><span class="pre">get_rhopol_rV_mapping()</span></code> for an application.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geqdsk</strong> – dict
Dictionary containing the g-EQDSK file as processed by the <em>omfit_eqdsk</em>
package.</p></li>
<li><p><strong>rho_pol</strong> – array, optional
Array corresponding to a grid in sqrt of normalized poloidal flux for which a
corresponding rvol grid should be found. If left to None, an arbitrary grid will be
created internally.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array</dt><dd><p>Major radius [m] on the HFS</p>
</dd>
<dt>Rlfs<span class="classifier">array</span></dt><dd><p>Major radius [m] on the LFS</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Rhfs</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.grids_utils.get_rhopol_rvol_mapping">
<code class="sig-prename descclassname">aurora.grids_utils.</code><code class="sig-name descname">get_rhopol_rvol_mapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">geqdsk</span></em>, <em class="sig-param"><span class="n">rho_pol</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/grids_utils.html#get_rhopol_rvol_mapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.grids_utils.get_rhopol_rvol_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute arrays allowing 1-to-1 mapping of rho_pol and rvol, both inside and
outside the LCFS.</p>
<p>rvol is defined as <span class="math notranslate nohighlight">\(\sqrt{V/(2 \pi^2 R_{axis}}\)</span> inside the LCFS. Outside of it,
we artificially expand the LCFS to fit true equilibrium at the midplane based
on the rho_pol grid (sqrt of normalized poloidal flux).</p>
<p>Method:</p>
<div class="math notranslate nohighlight">
\[\begin{split}r(\rho,\theta) = r_0(\rho) +  (r_{lcfs}(\theta) - r_{0,lcfs}) \times \mathcal{f} \\
z(\rho,\theta) = z_0      +  (z_{lcfs}(\theta) - z_0     ) \times \mathcal{f} \\
\mathcal{f} = \frac{ r(\rho,\theta=0) - r(\rho,\theta=180)}{r_{lcfs}(\theta=0)- r_{lcfs}(\theta=180)} \\
r_{0,lcfs} = \frac{1}{2} (r_{lcfs}(\theta=0)+ r_{lcfs}(\theta=180)) \\
r_0(\rho) = \frac{1}{2} (r(\rho,\theta=0) + r(\rho,\theta=180))\end{split}\]</div>
<p>The mapping between rho_pol and rvol allows one to interpolate inputs on a
rho_pol grid onto the rvol grid (in cm) used internally by the code.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geqdsk</strong> – dict
Dictionary containing the g-EQDSK file as processed by the <em>omfit_eqdsk</em>
package.</p></li>
<li><p><strong>rho_pol</strong> – array, optional
Array corresponding to a grid in sqrt of normalized poloidal flux for which a
corresponding rvol grid should be found. If left to None, an arbitrary grid will be
created internally.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array</dt><dd><p>Sqrt of normalized poloidal flux grid</p>
</dd>
<dt>rvol<span class="classifier">array</span></dt><dd><p>Mapping of rho_pol to a radial grid defined in terms of normalized flux surface volume.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>rho_pol</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-aurora.coords">
<span id="aurora-coords-module"></span><h2>aurora.coords module<a class="headerlink" href="#module-aurora.coords" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="aurora.coords.rV_vol_average">
<code class="sig-prename descclassname">aurora.coords.</code><code class="sig-name descname">rV_vol_average</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">quant</span></em>, <em class="sig-param"><span class="n">r_V</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/coords.html#rV_vol_average"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.coords.rV_vol_average" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Calculate a volume average of the given radially-dependent quantity on a r_V grid.</dt><dd><p>This function makes useof the fact that the r_V radial coordinate, defined as
r_V = sqrt{ V / (2 pi^2 R_{axis} },
maps shaped volumes onto a circular geometry, making volume averaging a trivial
operation via
langle Q</p>
</dd>
<dt>angle = Sigma_i Q(r_i) 2 pi Delta r_V</dt><dd><p>where $Delta r_V$ is the spacing between radial points in r_V.</p>
<p>Note that if the input r_V coordinate is extended outside the LCFS,
this function will return the effective volume average also in the SOL, since it is
agnostic to the presence of the LCFS.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>quant<span class="classifier">array, (space, …)</span></dt><dd><p>quantity that one wishes to volume-average. The first dimension must correspond to r_V,
but other dimensions may be exist afterwards.</p>
</dd>
<dt>r_V<span class="classifier">array, (space,)</span></dt><dd><p>Radial r_V coordinate in cm units.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>quant_vol_avg<span class="classifier">array, (space, …)</span></dt><dd><p>Volume average of the quantity given as an input, in the same units as in the input</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.coords.rad_coord_transform">
<code class="sig-prename descclassname">aurora.coords.</code><code class="sig-name descname">rad_coord_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">name_in</span></em>, <em class="sig-param"><span class="n">name_out</span></em>, <em class="sig-param"><span class="n">geqdsk</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/coords.html#rad_coord_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.coords.rad_coord_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform from one radial coordinate to another.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – array
input x coordinate</p></li>
<li><p><strong>name_in</strong> – str
input x coordinate name (‘rhon’,’r_V’,’rhop’,’rhov’,’Rmid’,’rmid’,’roa’)</p></li>
<li><p><strong>name_out</strong> – str
input x coordinate (‘rhon’, ‘r_V’, ‘rhop’,’rhov’,’Rmid’,’rmid’,’roa’)</p></li>
<li><p><strong>geqdsk</strong> – dict
gEQDSK dictionary, as obtained from the omfit-eqdsk package.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Conversion of <cite>x</cite> for the requested radial grid coordinate.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.coords.vol_average">
<code class="sig-prename descclassname">aurora.coords.</code><code class="sig-name descname">vol_average</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">quant</span></em>, <em class="sig-param"><span class="n">rhop</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'omfit'</span></em>, <em class="sig-param"><span class="n">geqdsk</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">device</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shot</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_geqdsk</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/coords.html#vol_average"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.coords.vol_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the volume average of the given radially-dependent quantity on a rhop grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quant</strong> – array, (space, …)
quantity that one wishes to volume-average. The first dimension must correspond to space,
but other dimensions may be exist afterwards.</p></li>
<li><p><strong>rhop</strong> – array, (space,)
Radial rhop coordinate in cm units.</p></li>
<li><p><strong>method</strong> – {‘omfit’,’fs’}
Method to evaluate the volume average. The two options correspond to the way to compute
volume averages via the OMFIT fluxSurfaces classes and via a simpler cumulative sum in r_V
coordinates. The methods only slightly differ in their results. Note that ‘omfit’ will fail if
rhop extends beyond the LCFS, while method ‘fs’ can estimate volume averages also into the SOL.
Default is method=’omfit’.</p></li>
<li><p><strong>geqdsk</strong> – output of the omfit_eqdsk.OMFITgeqdsk class, postprocessing the EFIT geqdsk file
containing the magnetic geometry. If this is left to None, the function internally tries to fetch
it using MDS+ and omfit_eqdsk. In this case, device, shot and time to fetch the equilibrium
are required.</p></li>
<li><p><strong>device</strong> – str
Device name. Note that routines for this device must be implemented in omfit_eqdsk for this
to work.</p></li>
<li><p><strong>shot</strong> – int
Shot number of the above device, e.g. 1101014019 for C-Mod.</p></li>
<li><p><strong>time</strong> – float
Time at which equilibrium should be fetched in units of ms.</p></li>
<li><p><strong>return_geqdsk</strong> – bool
If True, omfit_eqdsk dictionary is also returned</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array, (space, …)</dt><dd><p>Volume average of the quantity given as an input, in the same units as in the input.
If extrapolation beyond the range available from EFIT volume averages over a shorter section
of the radial grid will be attempted. This does not affect volume averages within the LCFS.</p>
</dd>
<dt>geqdsk<span class="classifier">dict</span></dt><dd><p>Only returned if return_geqdsk=True.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>quant_vol_avg</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-aurora.source_utils">
<span id="aurora-source-utils-module"></span><h2>aurora.source_utils module<a class="headerlink" href="#module-aurora.source_utils" title="Permalink to this headline">¶</a></h2>
<p>Methods related to impurity source functions.</p>
<p>sciortino, 2020</p>
<dl class="py function">
<dt id="aurora.source_utils.get_radial_source">
<code class="sig-prename descclassname">aurora.source_utils.</code><code class="sig-name descname">get_radial_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">namelist</span></em>, <em class="sig-param"><span class="n">rvol_grid</span></em>, <em class="sig-param"><span class="n">pro_grid</span></em>, <em class="sig-param"><span class="n">S_rates</span></em>, <em class="sig-param"><span class="n">Ti_eV</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/source_utils.html#get_radial_source"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.source_utils.get_radial_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain spatial dependence of source function.</p>
<p>If namelist[‘source_width_in’]==0 and namelist[‘source_width_out’]==0, the source
radial profile is defined as an exponential decay due to ionization of neutrals. This requires
S_rates, the ionization rate of neutral impurities, to be given with S_rates.shape=(len(rvol_grid),)</p>
<p>If namelist[‘imp_source_energy_eV’]&lt;0, the neutrals speed is taken as the thermal speed based
on Ti_eV, otherwise the value corresponding to namelist[‘imp_source_energy_eV’] is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>namelist</strong> – dict
Aurora namelist. Only elements referring to the spatial distribution and energy of
source atoms are accessed.</p></li>
<li><p><strong>rvol_grid</strong> – array (nr,)
Radial grid in volume-normalized coordinates [cm]</p></li>
<li><p><strong>S_rates</strong> – array (nr,)
Ionization rate of neutral impurity at initial time step.</p></li>
<li><p><strong>pro_grid</strong> – array (nr,)
Normalized first derivatives of the radial grid in volume-normalized coordinates.</p></li>
<li><p><strong>Ti_eV</strong> – array, optional (nr)
Background ion temperature, only used if source_width_in=source_width_out=0.0 and
imp_source_energy_eV&lt;=0, in which case the source impurity neutrals are taken to
have energy equal to the local Ti [eV].</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array (nr,)</dt><dd><p>Radial profile of the impurity neutral source.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>source_rad_prof</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.source_utils.get_source_time_history">
<code class="sig-prename descclassname">aurora.source_utils.</code><code class="sig-name descname">get_source_time_history</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">namelist</span></em>, <em class="sig-param"><span class="n">Raxis</span></em>, <em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/source_utils.html#get_source_time_history"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.source_utils.get_source_time_history" title="Permalink to this definition">¶</a></dt>
<dd><p>Load source time history based on current state of the namelist.</p>
<p>There are 4 options to describe the time-dependence of the source:</p>
<p>(1) namelist[‘source_type’] == ‘file’: in this case, a simply formatted
source file, with one time point and corresponding and source amplitude on each
line, is read in. This can describe an arbitrary time dependence, e.g.
as measured from an experimental diagnostic.</p>
<p>(2) namelist[‘source_type’] == ‘const’: in this case, a constant source
(e.g. a gas puff) is simulated. It is recommended to run the simulation for
&gt;100ms in order to see self-similar charge state profiles in time.</p>
<p>(3) namelist[‘source_type’] == ‘step’: this allows the creation of a source
that suddenly appears and suddenly stops, i.e. a rectangular “step”. The
duration of this step is given by namelist[‘step_source_duration’]. Multiple
step times can be given as a list in namelist[‘src_step_times’]; the amplitude
of the source at each step is given in namelist[‘src_step_rates’]</p>
<p>(4) namelist[‘source_type’] == ‘LBO’: this produces a model source from a LBO
injection, given by a convolution of a gaussian and an exponential. The required
parameters in this case are inside a namelist[‘LBO’] dictionary:
namelist[‘LBO’][‘t_start’], namelist[‘LBO’][‘t_rise’], namelist[‘LBO’][‘t_fall’],
namelist[‘LBO’][‘t_fall’], namelist[‘LBO’][‘n_particles’]. The “n_particles” parameter
corresponds to the amplitude of the source (the number of particles corresponding
to the integral over the source function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>namelist</strong> – dict
Aurora namelist dictionary.</p></li>
<li><p><strong>Raxis</strong> – float
Major radius at the magnetic axis [m]. This is needed to normalize the
source such that it is treated as toroidally symmetric – a necessary
idealization for 1.5D simulations.</p></li>
<li><p><strong>time</strong> – array (nt,), optional
Time array the source should be returned on.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array (nt,)</dt><dd><p>The source time history on the input time base.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>source_time_history</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.source_utils.lbo_source_function">
<code class="sig-prename descclassname">aurora.source_utils.</code><code class="sig-name descname">lbo_source_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t_start</span></em>, <em class="sig-param"><span class="n">t_rise</span></em>, <em class="sig-param"><span class="n">t_fall</span></em>, <em class="sig-param"><span class="n">n_particles</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">time_vec</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/source_utils.html#lbo_source_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.source_utils.lbo_source_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Model for the expected shape of the time-dependent source function,
using a convolution of a gaussian and an exponential decay.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_start</strong> – float or array-like [ms]
Injection time, beginning of source rise. If multiple values are given, they are
used to create multiple source functions.</p></li>
<li><p><strong>t_rise</strong> – float or array-like [ms]
Time scale of source rise. Similarly to t_start for multiple values.</p></li>
<li><p><strong>t_fall</strong> – float or array-like [ms]
Time scale of source decay.Similarly to t_start for multiple values.</p></li>
<li><p><strong>n_particles</strong> – float, opt
Total number of particles in source. Similarly to t_start for multiple values.
Defaults to 1.0.</p></li>
<li><p><strong>time_vec</strong> – array-like
Time vector on which to create source function. If left to None,
use a linearly spaced time vector including the main features of the function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array</dt><dd><p>Times for the source function of each given impurity</p>
</dd>
<dt>source<span class="classifier">array</span></dt><dd><p>Time history of the synthetized source function.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>time_vec</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.source_utils.read_source">
<code class="sig-prename descclassname">aurora.source_utils.</code><code class="sig-name descname">read_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/source_utils.html#read_source"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.source_utils.read_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a STRAHL source file from {imp}flx{shot}.dat locally.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> – str
Location of the file containing the STRAHL source file.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl>
<dt>array of float, (<cite>n</cite>,)</dt><dd><p>The timebase (in seconds).</p>
</dd>
<dt>s<span class="classifier">array of float, (<cite>n</cite>,)</span></dt><dd><p>The source function (#/s).</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>t</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.source_utils.write_source">
<code class="sig-prename descclassname">aurora.source_utils.</code><code class="sig-name descname">write_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">shot</span></em>, <em class="sig-param"><span class="n">imp</span><span class="o">=</span><span class="default_value">'Ca'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/source_utils.html#write_source"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.source_utils.write_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a STRAHL source file.</p>
<p>This will overwrite any {imp}flx{shot}.dat locally.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> – array of float, (<cite>n</cite>,)
The timebase (in seconds).</p></li>
<li><p><strong>s</strong> – array of float, (<cite>n</cite>,)
The source function (in particles/s).</p></li>
<li><p><strong>shot</strong> – int
Shot number, only used for saving to a .dat file</p></li>
<li><p><strong>imp</strong> – str, optional
Impurity species atomic symbol</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>str</dt><dd><p>Content of the source file written to {imp}flx{shot}.dat</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>contents</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-aurora.plot_tools">
<span id="aurora-plot-tools-module"></span><h2>aurora.plot_tools module<a class="headerlink" href="#module-aurora.plot_tools" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="aurora.plot_tools.get_color_cycle">
<code class="sig-prename descclassname">aurora.plot_tools.</code><code class="sig-name descname">get_color_cycle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/plot_tools.html#get_color_cycle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.plot_tools.get_color_cycle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="aurora.plot_tools.get_line_cycle">
<code class="sig-prename descclassname">aurora.plot_tools.</code><code class="sig-name descname">get_line_cycle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/plot_tools.html#get_line_cycle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.plot_tools.get_line_cycle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="aurora.plot_tools.get_ls_cycle">
<code class="sig-prename descclassname">aurora.plot_tools.</code><code class="sig-name descname">get_ls_cycle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/plot_tools.html#get_ls_cycle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.plot_tools.get_ls_cycle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="aurora.plot_tools.slider_plot">
<code class="sig-prename descclassname">aurora.plot_tools.</code><code class="sig-name descname">slider_plot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">xlabel</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">ylabel</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">zlabel</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">labels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">plot_sum</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">x_line</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y_line</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/plot_tools.html#slider_plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.plot_tools.slider_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a plot to explore multidimensional data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – array of float, (<cite>M</cite>,)
The abscissa. (in aurora, often this may be rhop)</p></li>
<li><p><strong>y</strong> – array of float, (<cite>N</cite>,)
The variable to slide over. (in aurora, often this may be time)</p></li>
<li><p><strong>z</strong> – array of float, (<cite>P</cite>, <cite>M</cite>, <cite>N</cite>)
The variables to plot.</p></li>
<li><p><strong>xlabel</strong> – str, optional
The label for the abscissa.</p></li>
<li><p><strong>ylabel</strong> – str, optional
The label for the slider.</p></li>
<li><p><strong>zlabel</strong> – str, optional
The label for the ordinate.</p></li>
<li><p><strong>labels</strong> – list of str with length <cite>P</cite>
The labels for each curve in <cite>z</cite>.</p></li>
<li><p><strong>plot_sum</strong> – bool, optional
If True, will also plot the sum over all <cite>P</cite> cases. Default is False.</p></li>
<li><p><strong>x_line</strong> – float, optional
x coordinate at which a vertical line will be drawn.</p></li>
<li><p><strong>y_line</strong> – float, optional
y coordinate at which a horizontal line will be drawn.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-aurora.default_nml">
<span id="aurora-default-nml-module"></span><h2>aurora.default_nml module<a class="headerlink" href="#module-aurora.default_nml" title="Permalink to this headline">¶</a></h2>
<p>Method to load default namelist. This should be complemented with additional info
by each user.</p>
<p>sciortino, July 2020</p>
<dl class="py function">
<dt id="aurora.default_nml.load_default_namelist">
<code class="sig-prename descclassname">aurora.default_nml.</code><code class="sig-name descname">load_default_namelist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/default_nml.html#load_default_namelist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.default_nml.load_default_namelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Load default namelist.
Users should modify and complement this for a successful run.</p>
</dd></dl>

</div>
<div class="section" id="module-aurora.interp">
<span id="aurora-interp-module"></span><h2>aurora.interp module<a class="headerlink" href="#module-aurora.interp" title="Permalink to this headline">¶</a></h2>
<p>This script contains a number of functions used for interpolation of kinetic profiles and D,V profiles in STRAHL.
Refer to the STRAHL manual for details.</p>
<dl class="py function">
<dt id="aurora.interp.exppol0">
<code class="sig-prename descclassname">aurora.interp.</code><code class="sig-name descname">exppol0</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span></em>, <em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">rLCFS</span></em>, <em class="sig-param"><span class="n">r</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/interp.html#exppol0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.interp.exppol0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="aurora.interp.exppol1">
<code class="sig-prename descclassname">aurora.interp.</code><code class="sig-name descname">exppol1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span></em>, <em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">rLCFS</span></em>, <em class="sig-param"><span class="n">r</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/interp.html#exppol1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.interp.exppol1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="aurora.interp.funct">
<code class="sig-prename descclassname">aurora.interp.</code><code class="sig-name descname">funct</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span></em>, <em class="sig-param"><span class="n">rLCFS</span></em>, <em class="sig-param"><span class="n">r</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/interp.html#funct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.interp.funct" title="Permalink to this definition">¶</a></dt>
<dd><p>Function ‘funct’ in STRAHL manual</p>
<dl class="simple">
<dt>The “params” input is broken down into 6 arguments:</dt><dd><p>y0 is core offset
y1 is edge offset
y2 (&gt;y0, &gt;y1) sets the gaussian amplification
p0 sets the width of the inner gaussian
P1 sets the width of the outer gaussian
p2 sets the location of the inner and outer peaks</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.interp.funct2">
<code class="sig-prename descclassname">aurora.interp.</code><code class="sig-name descname">funct2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span></em>, <em class="sig-param"><span class="n">rLCFS</span></em>, <em class="sig-param"><span class="n">r</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/interp.html#funct2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.interp.funct2" title="Permalink to this definition">¶</a></dt>
<dd><p>Function ‘funct2’ in STRAHL manual.</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.interp.interp">
<code class="sig-prename descclassname">aurora.interp.</code><code class="sig-name descname">interp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">rLCFS</span></em>, <em class="sig-param"><span class="n">r</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/interp.html#interp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.interp.interp" title="Permalink to this definition">¶</a></dt>
<dd><p>Function ‘interp’ used in STRAHL for D and V profiles.</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.interp.interp_quad">
<code class="sig-prename descclassname">aurora.interp.</code><code class="sig-name descname">interp_quad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">rLCFS</span></em>, <em class="sig-param"><span class="n">r</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/interp.html#interp_quad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.interp.interp_quad" title="Permalink to this definition">¶</a></dt>
<dd><p>Function ‘interp’ used for kinetic profiles.</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.interp.interpa_quad">
<code class="sig-prename descclassname">aurora.interp.</code><code class="sig-name descname">interpa_quad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">rLCFS</span></em>, <em class="sig-param"><span class="n">r</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/interp.html#interpa_quad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.interp.interpa_quad" title="Permalink to this definition">¶</a></dt>
<dd><p>Function ‘interpa’ used for kinetic profiles</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.interp.ratfun">
<code class="sig-prename descclassname">aurora.interp.</code><code class="sig-name descname">ratfun</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span></em>, <em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">rLCFS</span></em>, <em class="sig-param"><span class="n">r</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/interp.html#ratfun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.interp.ratfun" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-aurora.animate">
<span id="aurora-animate-module"></span><h2>aurora.animate module<a class="headerlink" href="#module-aurora.animate" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="aurora.animate.animate_aurora">
<code class="sig-prename descclassname">aurora.animate.</code><code class="sig-name descname">animate_aurora</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">xlabel</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">ylabel</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">zlabel</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">labels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">plot_sum</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">uniform_y_spacing</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">save_filename</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/animate.html#animate_aurora"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.animate.animate_aurora" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce animation of time- and radially-dependent results from aurora.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – array of float, (<cite>M</cite>,)
The abscissa. (in aurora, often this may be rhop)</p></li>
<li><p><strong>y</strong> – array of float, (<cite>N</cite>,)
The variable to slide over. (in aurora, often this may be time)</p></li>
<li><p><strong>z</strong> – array of float, (<cite>P</cite>, <cite>M</cite>, <cite>N</cite>)
The variables to plot.</p></li>
<li><p><strong>xlabel</strong> – str, optional
The label for the abscissa.</p></li>
<li><p><strong>ylabel</strong> – str, optional
The label for the animated coordinate. This is expected in a format such that ylabel.format(y_val)
will display a good moving label, e.g. ylabel=’t={:.4f} s’.</p></li>
<li><p><strong>zlabel</strong> – str, optional
The label for the ordinate.</p></li>
<li><p><strong>labels</strong> – list of str with length <cite>P</cite>
The labels for each curve in <cite>z</cite>.</p></li>
<li><p><strong>plot_sum</strong> – bool, optional
If True, will also plot the sum over all <cite>P</cite> cases. Default is False.</p></li>
<li><p><strong>uniform_y_spacing</strong> – bool, optional
If True, interpolate values in z onto a uniformly-spaced y grid</p></li>
<li><p><strong>save_filename</strong> – str
If a valid path/filename is provided, the animation will be saved here in mp4 format.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-aurora.particle_conserv">
<span id="aurora-particle-conserv-module"></span><h2>aurora.particle_conserv module<a class="headerlink" href="#module-aurora.particle_conserv" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="aurora.particle_conserv.check_particle_conserv">
<code class="sig-prename descclassname">aurora.particle_conserv.</code><code class="sig-name descname">check_particle_conserv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Raxis</span></em>, <em class="sig-param"><span class="n">ds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">filepath</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">linestyle</span><span class="o">=</span><span class="default_value">'-'</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">axs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/particle_conserv.html#check_particle_conserv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.particle_conserv.check_particle_conserv" title="Permalink to this definition">¶</a></dt>
<dd><p>Check time evolution and particle conservation in Aurora or STRAHL output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Raxis</strong> – float
Major radius on axis [m], used for volume integrals.</p></li>
<li><p><strong>ds</strong> – xarray dataset, optional
Dataset containing Aurora results, created using the xarray package.
See <code class="xref py py-meth docutils literal notranslate"><span class="pre">check_conservation()</span></code> for an illustration on how
to use this.</p></li>
<li><p><strong>filepath</strong> – str, optional
If provided, load results from STRAHL output file and check particle
particle conservation as for an Aurora run.</p></li>
<li><p><strong>linestyle</strong> – str, optional
matplotlib linestyle, default is ‘-‘ (continuous lines). Use this to
overplot lines on the same plots using different linestyles, e.g. to check
whether some aurora option makes particle conservation better or worse.</p></li>
<li><p><strong>plot</strong> – bool, optional
If True, plot time histories of particle densities in each simulation reservoir.</p></li>
<li><p><strong>axs</strong> – 2-tuple or array
array-like structure containing two matplotlib.Axes instances: the first one
for the separate particle time variation in each reservoir, the second for
the total particle-conservation check. This can be used to plot results
from several aurora runs on the same axes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>dict</dt><dd><p>Dictionary containing time histories across all reservoirs, useful for
the assessment of particle conservation.</p>
</dd>
<dt>axs<span class="classifier">2-tuple or array, only returned if plot=True</span></dt><dd><p>array-like structure containing two matplotlib.Axes instances, (ax1,ax2).
See optional input argument.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.particle_conserv.vol_int">
<code class="sig-prename descclassname">aurora.particle_conserv.</code><code class="sig-name descname">vol_int</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Raxis</span></em>, <em class="sig-param"><span class="n">ds</span></em>, <em class="sig-param"><span class="n">var</span></em>, <em class="sig-param"><span class="n">rhop_max</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/particle_conserv.html#vol_int"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.particle_conserv.vol_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a volume integral of an input variable. If the variable is f(t,x)
then the result is f(t). If the variable is f(t,*,x) then the result is f(t,charge)
when “*” represents charge, line index, etc…</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Raxis</strong> – float
Major radius on axis [cm]</p></li>
<li><p><strong>ds</strong> – xarray dataset
Dataset containing Aurora or STRAHL result</p></li>
<li><p><strong>var</strong> – str
Name of the variable in the strahl_result.cdf file</p></li>
<li><p><strong>rhop_max</strong> – float
Maximum normalized poloidal flux for integral. If not provided, integrate
over the entire simulation grid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array (nt,)</dt><dd><p>Time history of volume integrated variable</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>var_volint</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-aurora.nbi_neutrals">
<span id="aurora-nbi-neutrals-module"></span><h2>aurora.nbi_neutrals module<a class="headerlink" href="#module-aurora.nbi_neutrals" title="Permalink to this headline">¶</a></h2>
<p>Methods for neutral beam analysis, particularly in relation to impurity transport studies.
These script collects functions that should be device-agnostic.</p>
<dl class="py function">
<dt id="aurora.nbi_neutrals.beam_grid">
<code class="sig-prename descclassname">aurora.nbi_neutrals.</code><code class="sig-name descname">beam_grid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">uvw_src</span></em>, <em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">max_radius</span><span class="o">=</span><span class="default_value">255.0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/nbi_neutrals.html#beam_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.nbi_neutrals.beam_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to obtain the 3D orientation of a beam with respect to the device.
The uvw_src and (normalized) axis arrays may be obtained from the d3d_beams method
of fidasim_lib.py in the FIDASIM module in OMFIT.</p>
<p>This is inspired by <cite>beam_grid</cite> in fidasim_lib.py of the FIDASIM module (S. Haskey)
in OMFIT.</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.nbi_neutrals.bt_rate_maxwell_average">
<code class="sig-prename descclassname">aurora.nbi_neutrals.</code><code class="sig-name descname">bt_rate_maxwell_average</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sigma_fun</span></em>, <em class="sig-param"><span class="n">Ti</span></em>, <em class="sig-param"><span class="n">E_beam</span></em>, <em class="sig-param"><span class="n">m_bckg</span></em>, <em class="sig-param"><span class="n">m_beam</span></em>, <em class="sig-param"><span class="n">n_level</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/nbi_neutrals.html#bt_rate_maxwell_average"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.nbi_neutrals.bt_rate_maxwell_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Maxwellian reaction rate for a beam with atomic mass “m_beam”,
energy “E_beam”, firing into a target with atomic mass “m_bckg” and temperature “T”.</p>
<p>The “sigma_fun” argument must be a function for a specific charge and n-level of the beam particles.
Ref: FIDASIM atomic_tables.f90 bt_maxwellian_n_m.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma_fun</strong> – :py:meth
Function to compute a specific cross section [cm^2], function of energy/amu ONLY.
Expected call form: sigma_fun(erel/ared)</p></li>
<li><p><strong>Ti</strong> – float, 1D or 2D array
Target temperature [keV]. Results will be computed for each Ti value in a vectorized manner.</p></li>
<li><p><strong>E_beam</strong> – float
Beam energy [keV]</p></li>
<li><p><strong>m_bckg</strong> – float
Target atomic mass [amu]</p></li>
<li><p><strong>m_beam</strong> – float
Beam atomic mass [amu]</p></li>
<li><p><strong>n_level</strong> – int
n-level of beam. This is used to evaluate the hydrogen ionization potential,
below which an electron is unlikely to charge exchange with surrounding ions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>output reaction rate in [cm^3/s] units</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>rate</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.nbi_neutrals.bt_rate_maxwell_average_vec">
<code class="sig-prename descclassname">aurora.nbi_neutrals.</code><code class="sig-name descname">bt_rate_maxwell_average_vec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sigma_fun</span></em>, <em class="sig-param"><span class="n">Ti</span></em>, <em class="sig-param"><span class="n">E_beam</span></em>, <em class="sig-param"><span class="n">m_bckg</span></em>, <em class="sig-param"><span class="n">m_beam</span></em>, <em class="sig-param"><span class="n">n_level</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/nbi_neutrals.html#bt_rate_maxwell_average_vec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.nbi_neutrals.bt_rate_maxwell_average_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Maxwellian reaction rate for a beam with atomic mass “m_beam”,
energy “E_beam”, firing into a target with atomic mass “m_bckg” and temperature “T”.</p>
<p>The “sigma_fun” argument must be a function for a specific charge and n-level of the beam particles.
Ref: FIDASIM atomic_tables.f90 bt_maxwellian_n_m.</p>
<p>This version of the function attempts to vectorize the calculation such that we can have Ti
being a function of space and time and deal with integrations in vr and vz with no loops.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma_fun</strong> – :py:meth
Function to compute a specific cross section [cm^2], function of energy/amu ONLY.
Expected call form: sigma_fun(erel/ared)</p></li>
<li><p><strong>Ti</strong> – float, 1D or 2D array
Target temperature [keV]</p></li>
<li><p><strong>E_beam</strong> – float
Beam energy [keV]</p></li>
<li><p><strong>m_bckg</strong> – float
Target atomic mass [amu]</p></li>
<li><p><strong>m_beam</strong> – float
Beam atomic mass [amu]</p></li>
<li><p><strong>n_level</strong> – int
n-level of beam. This is used to evaluate the hydrogen ionization potential,
below which an electron is unlikely to charge exchange with surrounding ions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>output reaction rate in [cm^3/s] units</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>rate</p>
</dd>
</dl>
<p>~~~~~~~~~~ UNTESTED!~~~~~~~~~~~</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.nbi_neutrals.get_NBI_imp_cxr_q">
<code class="sig-prename descclassname">aurora.nbi_neutrals.</code><code class="sig-name descname">get_NBI_imp_cxr_q</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">neut_fsa</span></em>, <em class="sig-param"><span class="n">q</span></em>, <em class="sig-param"><span class="n">rhop_Ti</span></em>, <em class="sig-param"><span class="n">times_Ti</span></em>, <em class="sig-param"><span class="n">Ti_prof</span></em>, <em class="sig-param"><span class="n">include_fast</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">include_halo</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">debug_plots</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/nbi_neutrals.html#get_NBI_imp_cxr_q"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.nbi_neutrals.get_NBI_imp_cxr_q" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute flux-surface-averaged (FSA) charge exchange recombination for a given impurity with
neutral beam components, applying appropriate Maxwellian averaging of cross sections and
obtaining rates in [s^-1] units. This method expects all neutral components to be given in a
dictionary with a structure that is independent of NBI model.</p>
<p>Note that while Ti may be time-dependent, with a time base given by times_Ti, the FSA
neutrals are expected to be time-independent. Hence, the resulting CXR rates will only have
time dependence that reflects changes in Ti, but not the NBI.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>neut_fsa</strong> – dict
Dictionary containing FSA neutral densities in the form that is output by <a class="reference internal" href="#aurora.nbi_neutrals.get_neutrals_fsa" title="aurora.nbi_neutrals.get_neutrals_fsa"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_neutrals_fsa()</span></code></a>.</p></li>
<li><p><strong>q</strong> – int or float
Charge of impurity species</p></li>
<li><p><strong>rhop_Ti</strong> – array-like
Sqrt of poloidal flux radial coordinate for Ti profiles.</p></li>
<li><p><strong>times_Ti</strong> – array-like
Time base on which Ti_prof is given [s].</p></li>
<li><p><strong>Ti_prof</strong> – array-like
Ion temperature profile on the rhop_Ti, times_Ti bases.</p></li>
<li><p><strong>include_fast</strong> – bool, optional
If True, include CXR rates from fast NBI neutrals. Default is True.</p></li>
<li><p><strong>include_halo</strong> – bool, optional
If True, include CXR rates from themral NBI halo neutrals. Default is True.</p></li>
<li><p><strong>debug_plots</strong> – bool, optional
If True, plot several plots to assess the quality of the calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl>
<dt>dict</dt><dd><p>Dictionary containing CXR rates from NBI neutrals. This dictionary has analogous form to the
<a class="reference internal" href="#aurora.nbi_neutrals.get_neutrals_fsa" title="aurora.nbi_neutrals.get_neutrals_fsa"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_neutrals_fsa()</span></code></a> function, e.g. we have</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rates</span><span class="p">[</span><span class="n">beam</span><span class="p">][</span><span class="sa">f</span><span class="s1">&#39;n=</span><span class="si">{</span><span class="n">n_level</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">][</span><span class="s1">&#39;halo&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Rates are on a radial grid corresponding to the input neut_fsa[‘rhop’].</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>rates</p>
</dd>
</dl>
<p>For details on inputs and outputs, it is recommendeded to look at the internal plotting functions.</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.nbi_neutrals.get_ls_cycle">
<code class="sig-prename descclassname">aurora.nbi_neutrals.</code><code class="sig-name descname">get_ls_cycle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/nbi_neutrals.html#get_ls_cycle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.nbi_neutrals.get_ls_cycle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="aurora.nbi_neutrals.get_neutrals_fsa">
<code class="sig-prename descclassname">aurora.nbi_neutrals.</code><code class="sig-name descname">get_neutrals_fsa</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">neutrals</span></em>, <em class="sig-param"><span class="n">geqdsk</span></em>, <em class="sig-param"><span class="n">debug_plots</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/nbi_neutrals.html#get_neutrals_fsa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.nbi_neutrals.get_neutrals_fsa" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute charge exchange recombination for a given impurity with neutral beam components,
obtaining rates in [s^-1] units. This method expects all neutral components to be given in a
dictionary with a structure that is independent of NBI model (i.e. coming from FIDASIM, NUBEAM,
pencil calculations, etc.).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>neutrals</strong> – <p>dict
Dictionary containing fields
{“beams”,”names”,”R”,”Z”, beam1, beam2, etc.}
Here beam1,beam2,etc. are the names in neutrals[“beams”]. “names” are the names of each
beam component, e.g. ‘fdens’,’hdens’,’halo’, etc., ordered according to “names”.
“R”,”Z” are the major radius and vertical coordinates [cm] on which neutral density components are
given in elements such as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">neutrals</span><span class="p">[</span><span class="n">beams</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;n=0&quot;</span><span class="p">][</span><span class="n">name_idx</span><span class="p">]</span>
</pre></div>
</div>
<p>It is currently assumed that n=0,1 and 2 beam components are provided by the user.</p>
</p></li>
<li><p><strong>geqdsk</strong> – gEQDSK post-processed dictionary, as given by the omfit_eqdsk package.</p></li>
<li><p><strong>debug_plots</strong> – bool, optional
If True, various plots are displayed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl>
<dt>dict</dt><dd><p>Dictionary of flux-surface-averaged (FSA) neutral densities, in the same units as in the input.
Similarly to the input “neutrals”, this dictionary has a structure like</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">neutrals_ext</span><span class="p">[</span><span class="n">beam</span><span class="p">][</span><span class="sa">f</span><span class="s1">&#39;n=</span><span class="si">{</span><span class="n">n_level</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">][</span><span class="n">name_idx</span><span class="p">]</span>
</pre></div>
</div>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>neut_fsa</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.nbi_neutrals.rotation_matrix">
<code class="sig-prename descclassname">aurora.nbi_neutrals.</code><code class="sig-name descname">rotation_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">alpha</span></em>, <em class="sig-param"><span class="n">beta</span></em>, <em class="sig-param"><span class="n">gamma</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/nbi_neutrals.html#rotation_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.nbi_neutrals.rotation_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>See the table of all rotation possiblities, on the Tait Bryan side
<a class="reference external" href="https://en.wikipedia.org/wiki/Euler_angles#Tait.E2.80.93Bryan_angles">https://en.wikipedia.org/wiki/Euler_angles#Tait.E2.80.93Bryan_angles</a></p>
</dd></dl>

<dl class="py function">
<dt id="aurora.nbi_neutrals.tt_rate_maxwell_average">
<code class="sig-prename descclassname">aurora.nbi_neutrals.</code><code class="sig-name descname">tt_rate_maxwell_average</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sigma_fun</span></em>, <em class="sig-param"><span class="n">Ti</span></em>, <em class="sig-param"><span class="n">m_i</span></em>, <em class="sig-param"><span class="n">m_n</span></em>, <em class="sig-param"><span class="n">n_level</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/nbi_neutrals.html#tt_rate_maxwell_average"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.nbi_neutrals.tt_rate_maxwell_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Maxwellian reaction rate for an interaction between two thermal populations,
assumed to be of neutrals (mass m_n) and background ions (mass m_i).</p>
<p>The ‘sigma_fun’ argument must be a function for a specific charge and n-level of the neutral
particles. This allows evaluation of atomic rates for charge exchange interactions between thermal
beam halos and background ions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma_fun</strong> – python function
Function to compute a specific cross section [cm^2], function of energy/amu ONLY.
Expected call form: sigma_fun(erel/ared)</p></li>
<li><p><strong>Ti</strong> – float or 1D array
background ion and halo temperature [keV]</p></li>
<li><p><strong>m_i</strong> – float
mass of background ions [amu]</p></li>
<li><p><strong>m_n</strong> – float
mass of neutrals [amu]</p></li>
<li><p><strong>n_level</strong> – int
n-level of beam. This is used to evaluate the hydrogen ionization potential,
below which an electron is unlikely to charge exchange with surrounding ions.</p></li>
<li><p><strong>TODO</strong> – add effect of toroidal rotation! This will require making the integration in this</p></li>
<li><p><strong>2-dimensional.</strong> (<em>function</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>float or 1D array</dt><dd><p>output reaction rate in [cm^3/s] units</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>rate</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="aurora.nbi_neutrals.uvw_xyz">
<code class="sig-prename descclassname">aurora.nbi_neutrals.</code><code class="sig-name descname">uvw_xyz</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">w</span></em>, <em class="sig-param"><span class="n">origin</span></em>, <em class="sig-param"><span class="n">R</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/nbi_neutrals.html#uvw_xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.nbi_neutrals.uvw_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes array elements by multiplying the rows of the first
array by the columns of the second array. The second array
must have the same number of rows as the first array has
columns. The resulting array has the same number of rows as
the first array and the same number of columns as the second
array.</p>
<p>See uvw_to_xyz in fidasim.f90</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.nbi_neutrals.xyz_uvw">
<code class="sig-prename descclassname">aurora.nbi_neutrals.</code><code class="sig-name descname">xyz_uvw</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">origin</span></em>, <em class="sig-param"><span class="n">R</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/nbi_neutrals.html#xyz_uvw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.nbi_neutrals.xyz_uvw" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes array elements by multiplying the rows of the first
array by the columns of the second array. The second array
must have the same number of rows as the first array has
columns. The resulting array has the same number of rows as
the first array and the same number of columns as the second
array.</p>
<p>See xyz_to_uvw in fidasim.f90</p>
</dd></dl>

</div>
<div class="section" id="module-aurora.janev_smith_rates">
<span id="aurora-janev-smith-rates-module"></span><h2>aurora.janev_smith_rates module<a class="headerlink" href="#module-aurora.janev_smith_rates" title="Permalink to this headline">¶</a></h2>
<p>Script collecting rates from Janev &amp; Smith, NF 1993.
These are useful in aurora to compute total (n-unresolved) charge exchange rates between heavy ions and neutrals.</p>
<p>sciortino, 2020</p>
<dl class="py function">
<dt id="aurora.janev_smith_rates.js_sigma">
<code class="sig-prename descclassname">aurora.janev_smith_rates.</code><code class="sig-name descname">js_sigma</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">E</span></em>, <em class="sig-param"><span class="n">q</span></em>, <em class="sig-param"><span class="n">n1</span></em>, <em class="sig-param"><span class="n">n2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">type</span><span class="o">=</span><span class="default_value">'cx'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/janev_smith_rates.html#js_sigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.janev_smith_rates.js_sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross sections for collisional processes between beam neutrals and highly-charged
ions, from Janev &amp; Smith 1993.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>E</strong> – float
Normalized beam energy [keV/amu]</p></li>
<li><p><strong>q</strong> – int
Impurity charge before interaction (interacting ion is A^{q+})</p></li>
<li><p><strong>n1</strong> – int
Principal quantum number of beam hydrogen.</p></li>
<li><p><strong>n2</strong> – int
Principal quantum number of excited. This may not be needed for some transitions (if so, leave to None).</p></li>
<li><p><strong>type</strong> – str
Type of interaction. Possible choices:
{‘exc’,’ioniz’,’cx’}
where ‘cx’ refers to electron capture / charge exchange.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>float</dt><dd><p>Cross section of selected process, in [cm^2] units.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sigma</p>
</dd>
</dl>
<p>See comments in Janev &amp; Smith 1993 for uncertainty estimates.</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.janev_smith_rates.js_sigma_cx_n1_q1">
<code class="sig-prename descclassname">aurora.janev_smith_rates.</code><code class="sig-name descname">js_sigma_cx_n1_q1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">E</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/janev_smith_rates.html#js_sigma_cx_n1_q1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.janev_smith_rates.js_sigma_cx_n1_q1" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron capture cross section for
H^{+} + H(1s) –&gt; H + H^+
Section 2.3.1</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.janev_smith_rates.js_sigma_cx_n1_q2">
<code class="sig-prename descclassname">aurora.janev_smith_rates.</code><code class="sig-name descname">js_sigma_cx_n1_q2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">E</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/janev_smith_rates.html#js_sigma_cx_n1_q2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.janev_smith_rates.js_sigma_cx_n1_q2" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron capture cross section for
He^{2+} + H(1s) –&gt; He^+ + H^+
Section 3.3.1</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.janev_smith_rates.js_sigma_cx_n1_q4">
<code class="sig-prename descclassname">aurora.janev_smith_rates.</code><code class="sig-name descname">js_sigma_cx_n1_q4</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">E</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/janev_smith_rates.html#js_sigma_cx_n1_q4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.janev_smith_rates.js_sigma_cx_n1_q4" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron capture cross section for
Be^{4+} + H(1s) –&gt; Be^{3+} + H^+
Section 4.3.1</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.janev_smith_rates.js_sigma_cx_n1_q5">
<code class="sig-prename descclassname">aurora.janev_smith_rates.</code><code class="sig-name descname">js_sigma_cx_n1_q5</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">E</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/janev_smith_rates.html#js_sigma_cx_n1_q5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.janev_smith_rates.js_sigma_cx_n1_q5" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron capture cross section for
B^{5+} + H(1s) –&gt; B^{4+} + H^+
Section 4.3.2</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.janev_smith_rates.js_sigma_cx_n1_q6">
<code class="sig-prename descclassname">aurora.janev_smith_rates.</code><code class="sig-name descname">js_sigma_cx_n1_q6</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">E</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/janev_smith_rates.html#js_sigma_cx_n1_q6"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.janev_smith_rates.js_sigma_cx_n1_q6" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron capture cross section for
C^{6+} + H(1s) –&gt; C^{5+} + H^+
Section 4.3.3</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.janev_smith_rates.js_sigma_cx_n1_q8">
<code class="sig-prename descclassname">aurora.janev_smith_rates.</code><code class="sig-name descname">js_sigma_cx_n1_q8</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">E</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/janev_smith_rates.html#js_sigma_cx_n1_q8"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.janev_smith_rates.js_sigma_cx_n1_q8" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron capture cross section for
O^{8+} + H(1s) –&gt; O^{7+} + H^+
Section 4.3.4</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.janev_smith_rates.js_sigma_cx_n1_qg8">
<code class="sig-prename descclassname">aurora.janev_smith_rates.</code><code class="sig-name descname">js_sigma_cx_n1_qg8</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">E</span></em>, <em class="sig-param"><span class="n">q</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/janev_smith_rates.html#js_sigma_cx_n1_qg8"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.janev_smith_rates.js_sigma_cx_n1_qg8" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron capture cross section for
A^{q+} + H(1s) –&gt; A^{(q-1)+} + H^+,   q&gt;8
Section 4.3.5, p.172</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.janev_smith_rates.js_sigma_cx_n2_q2">
<code class="sig-prename descclassname">aurora.janev_smith_rates.</code><code class="sig-name descname">js_sigma_cx_n2_q2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">E</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/janev_smith_rates.html#js_sigma_cx_n2_q2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.janev_smith_rates.js_sigma_cx_n2_q2" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron capture cross section for
He^{2+} + H(n=2) –&gt; He^+ + H^+
Section 3.3.2</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.janev_smith_rates.js_sigma_cx_ng1_q1">
<code class="sig-prename descclassname">aurora.janev_smith_rates.</code><code class="sig-name descname">js_sigma_cx_ng1_q1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">E</span></em>, <em class="sig-param"><span class="n">n1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/janev_smith_rates.html#js_sigma_cx_ng1_q1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.janev_smith_rates.js_sigma_cx_ng1_q1" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron capture cross section for
H^{+} + H(n) –&gt; H + H^+ , n&gt;1
Section 2.3.2</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.janev_smith_rates.js_sigma_cx_ng1_qg3">
<code class="sig-prename descclassname">aurora.janev_smith_rates.</code><code class="sig-name descname">js_sigma_cx_ng1_qg3</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">E</span></em>, <em class="sig-param"><span class="n">n1</span></em>, <em class="sig-param"><span class="n">q</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/janev_smith_rates.html#js_sigma_cx_ng1_qg3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.janev_smith_rates.js_sigma_cx_ng1_qg3" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron capture cross section for
A^{q+} + H^*(n) –&gt; A^{(q-1)+}+H^+ , q&gt;3
Section 4.3.6, p.174</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.janev_smith_rates.js_sigma_cx_ng2_q2">
<code class="sig-prename descclassname">aurora.janev_smith_rates.</code><code class="sig-name descname">js_sigma_cx_ng2_q2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">E</span></em>, <em class="sig-param"><span class="n">n1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/janev_smith_rates.html#js_sigma_cx_ng2_q2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.janev_smith_rates.js_sigma_cx_ng2_q2" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron capture cross section for
He^{2+} + H*(n) –&gt; He^+ + H^+ , n&gt;2
Section 3.2.3</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.janev_smith_rates.js_sigma_ioniz_n1_q8">
<code class="sig-prename descclassname">aurora.janev_smith_rates.</code><code class="sig-name descname">js_sigma_ioniz_n1_q8</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">E</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/janev_smith_rates.html#js_sigma_ioniz_n1_q8"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.janev_smith_rates.js_sigma_ioniz_n1_q8" title="Permalink to this definition">¶</a></dt>
<dd><p>Ionization cross section for
O^{8+} + H(1s) –&gt; O^{8+} + H^+ +e^-
Section 4.2.4</p>
</dd></dl>

<dl class="py function">
<dt id="aurora.janev_smith_rates.plot_js_sigma">
<code class="sig-prename descclassname">aurora.janev_smith_rates.</code><code class="sig-name descname">plot_js_sigma</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">18</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/aurora/janev_smith_rates.html#plot_js_sigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aurora.janev_smith_rates.plot_js_sigma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-aurora">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-aurora" title="Permalink to this headline">¶</a></h2>
<dl class="py data">
<dt id="aurora.name">
<code class="sig-prename descclassname">aurora.</code><code class="sig-name descname">name</code><em class="property"> = 'aurora'</em><a class="headerlink" href="#aurora.name" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#module-aurora" title="aurora"><code class="xref py py-mod docutils literal notranslate"><span class="pre">aurora</span></code></a></p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="atomic_data.html" class="btn btn-neutral float-left" title="Atomic data" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, F.Sciortino

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>