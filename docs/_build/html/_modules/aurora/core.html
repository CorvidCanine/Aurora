

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aurora.core &mdash; Aurora 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> Aurora
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../requirements.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../params.html">Input parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../atomic_data.html">Atomic data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../citing.html">Citing Aurora</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contacts.html">Questions and contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aurora.html">Aurora modules</a></li>
</ul>

            
          
    <a href="genindex.html">Index</a>
  
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Aurora</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>aurora.core</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aurora.core</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;This module includes the core class to set up simulations with :py:mod:`aurora`. The :py:class:`~aurora.core.aurora_sim` takes as input a namelist dictionary and a g-file dictionary (and possibly other optional argument) and allows creation of grids, interpolation of atomic rates and other steps before running the forward model.</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">scipy.io</span>
<span class="kn">import</span> <span class="nn">copy</span><span class="o">,</span><span class="nn">os</span><span class="o">,</span><span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">omfit_commonclasses.utils_math</span> <span class="kn">import</span> <span class="n">atomic_element</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_aurora</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">interp</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">atomic</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">grids_utils</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">source_utils</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">particle_conserv</span>
<span class="kn">from</span> <span class="nn">IPython</span> <span class="kn">import</span> <span class="n">embed</span>
<span class="kn">import</span> <span class="nn">omfit_eqdsk</span>
<span class="kn">from</span> <span class="nn">scipy.constants</span> <span class="kn">import</span> <span class="n">e</span> <span class="k">as</span> <span class="n">q_electron</span><span class="p">,</span> <span class="n">m_p</span>
<span class="kn">import</span> <span class="nn">xarray</span>


<div class="viewcode-block" id="aurora_sim"><a class="viewcode-back" href="../../aurora.html#aurora.core.aurora_sim">[docs]</a><span class="k">class</span> <span class="nc">aurora_sim</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Class to setup and run aurora simulations.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namelist</span><span class="p">,</span> <span class="n">geqdsk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbi_cxr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Setup aurora simulation input dictionary from the given namelist.</span>

<span class="sd">        Args:</span>
<span class="sd">            namelist : dict</span>
<span class="sd">                Dictionary containing aurora inputs. See default_nml.py for some defaults, </span>
<span class="sd">                which users should modify for their runs.</span>
<span class="sd">            geqdsk : dict, optional</span>
<span class="sd">                EFIT gfile as returned after postprocessing by the :py:mod:`omfit_eqdsk` </span>
<span class="sd">                package (OMFITgeqdsk class). If left to None (default), the geqdsk dictionary </span>
<span class="sd">                is constructed starting from the gfile in the MDS+ tree.</span>
<span class="sd">            nbi_cxr : array, optional</span>
<span class="sd">                If namelist[&#39;nbi_cxr&#39;]=True, this array represents the charge exchange rates </span>
<span class="sd">                with NBI neutrals, fast and/or thermal, across the entire radius and on the </span>
<span class="sd">                time base of interest. </span>
<span class="sd">                Creating this input is not trivial and must be done externally to aurora. </span>
<span class="sd">                General steps:</span>
<span class="sd">                - get density of fast NBI neutrals (both fast and thermal/halo) ---&gt; n0_nbi, n0_halo</span>
<span class="sd">                - get total rates (n-unresolved) for CX with NBI neutrals --&gt; _alpha_CX_NBI_rates</span>
<span class="sd">                - thermal rates for the halo may be from ADAS CCD files or from the same methods used </span>
<span class="sd">                for fast neutrals</span>
<span class="sd">                - sum n0_nbi *  alpha_CX_NBI_rates + n0_halo * alpha_CX_rates</span>
<span class="sd">                This method still needs more testing within this class. Please contact author for details. </span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span> <span class="o">=</span> <span class="n">namelist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span> <span class="o">=</span> <span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;kin_profs&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbi_cxr</span> <span class="o">=</span> <span class="n">nbi_cxr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imp</span> <span class="o">=</span> <span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;imp&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">geqdsk</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Fetch geqdsk from MDS+ (using EFIT01) and post-process it using the OMFIT geqdsk format.</span>
            <span class="n">geqdsk</span> <span class="o">=</span> <span class="n">omfit_eqdsk</span><span class="o">.</span><span class="n">OMFITgeqdsk</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">from_mdsplus</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;device&#39;</span><span class="p">],</span><span class="n">shot</span><span class="o">=</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;shot&#39;</span><span class="p">],</span>
                                                              <span class="n">time</span><span class="o">=</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">SNAPfile</span><span class="o">=</span><span class="s1">&#39;EFIT01&#39;</span><span class="p">,</span>
                                                              <span class="n">fail_if_out_of_range</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                              <span class="n">time_diff_warning_threshold</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

        <span class="c1"># Get r_V to rho_pol mapping</span>
        <span class="n">rho_pol</span><span class="p">,</span> <span class="n">_rvol</span> <span class="o">=</span> <span class="n">grids_utils</span><span class="o">.</span><span class="n">get_rhopol_rvol_mapping</span><span class="p">(</span><span class="n">geqdsk</span><span class="p">)</span>
        <span class="n">rvol_lcfs</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">rho_pol</span><span class="p">,</span><span class="n">_rvol</span><span class="p">)(</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rvol_lcfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;rvol_lcfs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">rvol_lcfs</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># set limit on accuracy</span>
        
        <span class="c1"># create radial grid</span>
        <span class="n">grid_params</span> <span class="o">=</span> <span class="n">grids_utils</span><span class="o">.</span><span class="n">create_radial_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rvol_grid</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pro_grid</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">qpr_grid</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">prox_param</span> <span class="o">=</span> <span class="n">grid_params</span>

        <span class="c1"># get rho_poloidal grid corresponding to aurora internal (rvol) grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rhop_grid</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">_rvol</span><span class="p">,</span><span class="n">rho_pol</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">rvol_grid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rhop_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c1"># enforce on axis</span>
        
        <span class="c1"># Save R on LFS and HFS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Rhfs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rlfs</span> <span class="o">=</span> <span class="n">grids_utils</span><span class="o">.</span><span class="n">get_HFS_LFS</span><span class="p">(</span><span class="n">geqdsk</span><span class="p">,</span> <span class="n">rho_pol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rhop_grid</span><span class="p">)</span>

        <span class="c1"># define time grid (&#39;timing&#39; must be in namelist)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_time</span> <span class="o">=</span> <span class="n">grids_utils</span><span class="o">.</span><span class="n">create_time_grid</span><span class="p">(</span><span class="n">timing</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;timing&#39;</span><span class="p">],</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">save_time</span><span class="p">]</span>

        <span class="c1"># get kinetic profiles on the radial and (internal) temporal grids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ne</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_Te</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ti</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_n0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_aurora_kin_profs</span><span class="p">()</span>

        <span class="c1"># store also kinetic profiles on output time grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ne</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ne</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">save_time</span><span class="p">,:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Te</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Te</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">save_time</span><span class="p">,:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ti</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ti</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">save_time</span><span class="p">,:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n0</span>  <span class="c1"># at present, n0 is assumed to be time-indpt</span>
        
        <span class="c1"># Get time-dependent parallel loss rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">par_loss_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_par_loss_rate</span><span class="p">()</span>

        <span class="c1"># Obtain atomic rates on the computational time and radial grids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_rates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_rates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_time_dept_atomic_rates</span><span class="p">()</span>
        
        <span class="c1"># create array of 0&#39;s of length equal to self.time_grid, with 1&#39;s where sawteeth must be triggered</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saw_on</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_grid</span><span class="p">)</span>
        <span class="n">input_saw_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;saw_model&#39;</span><span class="p">][</span><span class="s1">&#39;times&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saw_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">input_saw_times</span><span class="p">)[</span><span class="n">input_saw_times</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">time_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;saw_model&#39;</span><span class="p">][</span><span class="s1">&#39;saw_flag&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">saw_times</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saw_on</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">time_grid</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">saw_times</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># source function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Raxis</span> <span class="o">=</span> <span class="n">geqdsk</span><span class="p">[</span><span class="s1">&#39;RMAXIS&#39;</span><span class="p">]</span> <span class="c1"># m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_time_history</span> <span class="o">=</span> <span class="n">source_utils</span><span class="o">.</span><span class="n">get_source_time_history</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Raxis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_grid</span>
        <span class="p">)</span>
        
        <span class="c1"># get radial profile of source function when the impurity source begins</span>
        <span class="n">source_tidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_time_history</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_rad_prof</span> <span class="o">=</span> <span class="n">source_utils</span><span class="o">.</span><span class="n">get_radial_source</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">,</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">rvol_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pro_grid</span><span class="p">,</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">S_rates</span><span class="p">[:,</span><span class="n">source_tidx</span><span class="p">],</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">_Ti</span><span class="p">[</span><span class="n">source_tidx</span><span class="p">,:])</span> 

        <span class="c1"># get maximum Z of impurity ion</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">atomic_element</span><span class="p">(</span><span class="n">symbol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">imp</span><span class="p">)</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Z_imp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="s1">&#39;Z&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_imp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
        
        <span class="c1"># Extract other inputs from namelist:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mixing_radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;saw_model&#39;</span><span class="p">][</span><span class="s1">&#39;rmix&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decay_length_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;SOL_decay&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wall_recycling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;wall_recycling&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_div_fraction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;divbls&#39;</span><span class="p">]</span>   <span class="c1"># change of nomenclature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_div_SOL_ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;tau_div_SOL_ms&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_pump_ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;tau_pump_ms&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_rcl_ret_ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;tau_rcl_ret_ms&#39;</span><span class="p">]</span>
        
        <span class="c1"># if recycling flag is set to False, then prevent any divertor return flows</span>
        <span class="c1"># To include divertor return flows but no recycling, user should use wall_recycling=0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;recycling_flag&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wall_recycling</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>  <span class="c1"># no divertor return flows</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bound_sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;bound_sep&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lim_sep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;lim_sep&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sawtooth_erfc_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;saw_model&#39;</span><span class="p">][</span><span class="s1">&#39;sawtooth_erfc_width&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cxr_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;cxr_flag&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbi_cxr_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;nbi_cxr_flag&#39;</span><span class="p">]</span>

        
        
<div class="viewcode-block" id="aurora_sim.interp_kin_prof"><a class="viewcode-back" href="../../aurora.html#aurora.core.aurora_sim.interp_kin_prof">[docs]</a>    <span class="k">def</span> <span class="nf">interp_kin_prof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prof</span><span class="p">):</span> 
        <span class="sd">&#39;&#39;&#39; Interpolate the given kinetic profile on the radial and temporal grids [units of s].</span>
<span class="sd">        This function extrapolates in the SOL based on input options using the same methods as in STRAHL.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="n">prof</span><span class="p">][</span><span class="s1">&#39;times&#39;</span><span class="p">]</span>

        <span class="n">r_lcfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">rhop_grid</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">rvol_grid</span><span class="p">)</span>

        <span class="c1"># extrapolate profiles outside of LCFS by exponential decays</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rhop_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rvol_grid</span><span class="p">,</span><span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="n">prof</span><span class="p">][</span><span class="s1">&#39;rhop&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="n">prof</span><span class="p">][</span><span class="s1">&#39;fun&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;interp&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;decay&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="n">prof</span><span class="p">]:</span>
                <span class="c1"># if decay length in the SOL was not given by the user, assume a decay length of 1cm</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Namelist did not provide a </span><span class="si">{</span><span class="n">prof</span><span class="si">}</span><span class="s1"> decay length for the SOL. Setting it to 1cm.&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="n">prof</span><span class="p">][</span><span class="s1">&#39;decay&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="n">prof</span><span class="p">][</span><span class="s1">&#39;vals&#39;</span><span class="p">]))</span>
                
            <span class="n">data</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">interp_quad</span><span class="p">(</span><span class="n">r</span><span class="o">/</span><span class="n">r_lcfs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="n">prof</span><span class="p">][</span><span class="s1">&#39;vals&#39;</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="n">prof</span><span class="p">][</span><span class="s1">&#39;decay&#39;</span><span class="p">],</span><span class="n">r_lcfs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">rvol_grid</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">&lt;</span> <span class="mf">1.01</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="n">prof</span><span class="p">][</span><span class="s1">&#39;fun&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;interpa&#39;</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">interpa_quad</span><span class="p">(</span><span class="n">r</span><span class="o">/</span><span class="n">r_lcfs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="n">prof</span><span class="p">][</span><span class="s1">&#39;vals&#39;</span><span class="p">],</span><span class="n">r_lcfs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">rvol_grid</span><span class="p">)</span>

        <span class="c1"># linear interpolation in time</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># time-dept</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">times</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_grid</span><span class="p">,</span><span class="o">*</span><span class="n">times</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># time-indpt: same kin profs at every time point</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_grid</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
            
        <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="aurora_sim.get_aurora_kin_profs"><a class="viewcode-back" href="../../aurora.html#aurora.core.aurora_sim.get_aurora_kin_profs">[docs]</a>    <span class="k">def</span> <span class="nf">get_aurora_kin_profs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_T</span><span class="o">=</span><span class="mf">1.01</span><span class="p">,</span> <span class="n">min_ne</span><span class="o">=</span><span class="mf">1e10</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get kinetic profiles on radial and time grids.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># ensure 2-dimensional inputs:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="s1">&#39;ne&#39;</span><span class="p">][</span><span class="s1">&#39;vals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="s1">&#39;ne&#39;</span><span class="p">][</span><span class="s1">&#39;vals&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="s1">&#39;Te&#39;</span><span class="p">][</span><span class="s1">&#39;vals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="s1">&#39;Te&#39;</span><span class="p">][</span><span class="s1">&#39;vals&#39;</span><span class="p">])</span>
        
        <span class="n">Te</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_kin_prof</span><span class="p">(</span><span class="s1">&#39;Te&#39;</span><span class="p">)</span>
        <span class="n">ne</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_kin_prof</span><span class="p">(</span><span class="s1">&#39;ne&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;Ti&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span> <span class="ow">and</span> <span class="s1">&#39;vals&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="s1">&#39;Ti&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="s1">&#39;Ti&#39;</span><span class="p">][</span><span class="s1">&#39;vals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kin_profs</span><span class="p">[</span><span class="s1">&#39;Ti&#39;</span><span class="p">][</span><span class="s1">&#39;vals&#39;</span><span class="p">])</span>
            <span class="n">Ti</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_kin_prof</span><span class="p">(</span><span class="s1">&#39;Ti&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ti</span> <span class="o">=</span> <span class="n">Te</span>

        <span class="c1"># get neutral background ion density</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cxr_flag&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">n0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_kin_prof</span><span class="p">(</span><span class="s1">&#39;n0&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n0</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># set minima in temperature and density</span>
        <span class="n">Te</span><span class="p">[</span><span class="n">Te</span> <span class="o">&lt;</span> <span class="n">min_T</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_T</span>
        <span class="n">Ti</span><span class="p">[</span><span class="n">Ti</span> <span class="o">&lt;</span> <span class="n">min_T</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_T</span>
        <span class="n">ne</span><span class="p">[</span><span class="n">ne</span> <span class="o">&lt;</span> <span class="n">min_ne</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_ne</span>

        <span class="c1"># make sure that Te,ne have the same shape at this stage (allow n0 to be time-indpt)</span>
        <span class="n">ne</span><span class="p">,</span><span class="n">Te</span><span class="p">,</span><span class="n">Ti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">ne</span><span class="p">,</span><span class="n">Te</span><span class="p">,</span><span class="n">Ti</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ne</span><span class="p">,</span><span class="n">Te</span><span class="p">,</span><span class="n">Ti</span><span class="p">,</span><span class="n">n0</span></div>


<div class="viewcode-block" id="aurora_sim.get_time_dept_atomic_rates"><a class="viewcode-back" href="../../aurora.html#aurora.core.aurora_sim.get_time_dept_atomic_rates">[docs]</a>    <span class="k">def</span> <span class="nf">get_time_dept_atomic_rates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Obtain time-dependent ionization and recombination rates for a simulation run.</span>
<span class="sd">        If kinetic profiles are given as time-independent, atomic rates for each time slice</span>
<span class="sd">        will be set to be the same.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">lne</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ne</span><span class="p">)</span>
        <span class="n">lTe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Te</span><span class="p">)</span>

        <span class="c1"># get TIME-DEPENDENT atomic rates</span>
        <span class="n">atom_data</span> <span class="o">=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">get_atom_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imp</span><span class="p">,[</span><span class="s1">&#39;acd&#39;</span><span class="p">,</span><span class="s1">&#39;scd&#39;</span><span class="p">])</span>

        <span class="c1"># get electron impact ionization and radiative recombination rates in units of [s^-1]</span>
        <span class="n">S_rates</span> <span class="o">=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">interp_atom_prof</span><span class="p">(</span><span class="n">atom_data</span><span class="p">[</span><span class="s1">&#39;scd&#39;</span><span class="p">],</span><span class="n">lne</span><span class="p">,</span> <span class="n">lTe</span><span class="p">)</span>
        <span class="n">alpha_rates</span> <span class="o">=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">interp_atom_prof</span><span class="p">(</span><span class="n">atom_data</span><span class="p">[</span><span class="s1">&#39;acd&#39;</span><span class="p">],</span><span class="n">lne</span><span class="p">,</span> <span class="n">lTe</span><span class="p">)</span>

        <span class="c1"># define effective recombination rate as R:</span>
        <span class="n">R_rates</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">alpha_rates</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;cxr_flag&#39;</span><span class="p">]:</span>
            <span class="c1"># include thermal charge exchange recombination</span>
            <span class="n">atom_data</span> <span class="o">=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">get_atom_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imp</span><span class="p">,[</span><span class="s1">&#39;ccd&#39;</span><span class="p">])</span>

            <span class="n">lTi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ti</span><span class="p">)</span>
            <span class="n">alpha_CX_rates</span> <span class="o">=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">interp_atom_prof</span><span class="p">(</span><span class="n">atom_data</span><span class="p">[</span><span class="s1">&#39;ccd&#39;</span><span class="p">],</span> <span class="n">lne</span><span class="p">,</span> <span class="n">lTi</span><span class="p">,</span> <span class="n">x_multiply</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># change rates from units of [1/s/cm^3] to [1/s] ---&gt; this is the result of STRAHL&#39;s `sas&#39; subroutine</span>
            <span class="n">R_rates</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">alpha_CX_rates</span><span class="p">[:,:</span><span class="n">alpha_rates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],:]</span>   <span class="c1"># select only relevant CCD ion stages (useful for Foster scaling)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;nbi_cxr_flag&#39;</span><span class="p">]:</span>
            <span class="c1"># include charge exchange between NBI neutrals and impurities</span>
            <span class="n">R_rates</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbi_cxr</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># nz=nion of rates arrays must be filled with zeros - final shape: (nr,nion,nt)</span>
        <span class="n">S_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S_rates</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">S_rates</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">]]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">R_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">R_rates</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">R_rates</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">]]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># broadcast in the requested time-dependent shape</span>
        <span class="n">S_rates</span><span class="p">,</span><span class="n">R_rates</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">S_rates</span><span class="p">,</span><span class="n">R_rates</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">time_grid</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>

        <span class="c1"># set up as Fortran order in memory for speed</span>
        <span class="n">S_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">S_rates</span><span class="p">)</span>
        <span class="n">R_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">R_rates</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">S_rates</span><span class="p">,</span> <span class="n">R_rates</span></div>





<div class="viewcode-block" id="aurora_sim.get_par_loss_rate"><a class="viewcode-back" href="../../aurora.html#aurora.core.aurora_sim.get_par_loss_rate">[docs]</a>    <span class="k">def</span> <span class="nf">get_par_loss_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trust_SOL_Ti</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Calculate the parallel loss frequency on the radial and temporal grids [1/s].</span>

<span class="sd">        trust_SOL_Ti should generally be set to False, unless specific Ti measurements are available</span>
<span class="sd">        in the SOL.</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># background mass number (=2 for D)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">atomic_element</span><span class="p">(</span><span class="n">symbol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;main_element&#39;</span><span class="p">])</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">main_ion_A</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>

        <span class="c1"># factor for v = machnumber * sqrt((3T_i+T_e)k/m)</span>
        <span class="n">vpf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;SOL_mach&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q_electron</span><span class="o">/</span><span class="n">m_p</span><span class="o">/</span><span class="n">main_ion_A</span><span class="p">)</span>  <span class="c1"># v[m/s]=vpf*sqrt(T[ev])</span>

        <span class="c1"># number of points inside of LCFS</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rvol_grid</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;rvol_lcfs&#39;</span><span class="p">],</span><span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
        <span class="n">idl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rvol_grid</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;rvol_lcfs&#39;</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;lim_sep&#39;</span><span class="p">],</span><span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>

        <span class="c1"># Calculate parallel loss frequency using different connection lengths in the SOL and in the limiter shadow</span>
        <span class="n">dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Te</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c1"># space x time</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">trust_SOL_Ti</span><span class="p">:</span>
            <span class="c1"># Ti may not be reliable in SOL, replace it by Te</span>
            <span class="n">Ti</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Te</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ti</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ti</span>

        <span class="c1"># open SOL</span>
        <span class="n">dv</span><span class="p">[</span><span class="n">ids</span><span class="p">:</span><span class="n">idl</span><span class="p">]</span> <span class="o">=</span> <span class="n">vpf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="n">Ti</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">ids</span><span class="p">:</span><span class="n">idl</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Te</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">ids</span><span class="p">:</span><span class="n">idl</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;clen_divertor&#39;</span><span class="p">]</span>

        <span class="c1"># limiter shadow</span>
        <span class="n">dv</span><span class="p">[</span><span class="n">idl</span><span class="p">:]</span> <span class="o">=</span> <span class="n">vpf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="n">Ti</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">idl</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Te</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">idl</span><span class="p">:])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">namelist</span><span class="p">[</span><span class="s1">&#39;clen_limiter&#39;</span><span class="p">]</span>

        <span class="n">dv</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">dv</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">time_grid</span><span class="p">[</span><span class="kc">None</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">dv</span><span class="p">)</span></div>






<div class="viewcode-block" id="aurora_sim.run_aurora"><a class="viewcode-back" href="../../aurora.html#aurora.core.aurora_sim.run_aurora">[docs]</a>    <span class="k">def</span> <span class="nf">run_aurora</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">D_z</span><span class="p">,</span> <span class="n">V_z</span><span class="p">,</span>
                   <span class="n">times_DV</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nz_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alg_opt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">evolneut</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">use_julia</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Run a simulation using inputs in the given dictionary and D,v profiles as a function</span>
<span class="sd">        of space, time and potentially also ionization state. Users may give an initial state of each</span>
<span class="sd">        ion charge state as an input.</span>

<span class="sd">        Results can be conveniently visualized with time-slider using</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            aurora.slider_plot(rhop,time, nz.transpose(1,2,0),</span>
<span class="sd">                               xlabel=r&#39;$\\rho_p$&#39;, ylabel=&#39;time [s]&#39;, </span>
<span class="sd">                               zlabel=r&#39;$n_z$ [cm$^{-3}$]&#39;, plot_sum=True,</span>
<span class="sd">                               labels=[f&#39;Ca$^{{{str(i)}}}$&#39; for i in np.arange(nz_w.shape[1]])</span>

<span class="sd">        Args:</span>
<span class="sd">            D_z, V_z: arrays, shape of (space,time,nZ) or (space,time) or (space,)</span>
<span class="sd">                Diffusion and convection coefficients, in units of cm^2/s and cm/s, respectively.</span>
<span class="sd">                This may be given as a function of (space,time) or (space,nZ, time), where nZ indicates</span>
<span class="sd">                the number of charge states. If D_z and V_z are found to be have only 2 dimensions, </span>
<span class="sd">                it is assumed that all charge states should have the same transport coefficients.</span>
<span class="sd">                If they are only 1-D, it is further assumed that they are time-independent. </span>
<span class="sd">                Note that it is assumed that D_z and V_z profiles are already on the self.rvol_grid </span>
<span class="sd">                radial grid.</span>
<span class="sd">            times_DV : 1D array, optional</span>
<span class="sd">                Array of times at which D_z and V_z profiles are given. By Default, this is None, </span>
<span class="sd">                which implies that D_z and V_z are time independent. </span>
<span class="sd">            nz_init: array, shape of (space, nZ)</span>
<span class="sd">                Impurity charge states at the initial time of the simulation. If left to None, this is</span>
<span class="sd">                internally set to an array of 0&#39;s.</span>
<span class="sd">            alg_opt : int, optional</span>
<span class="sd">                If alg_opt=1, use the finite-volume algorithm proposed by Linder et al. NF 2020. </span>
<span class="sd">                If alg_opt=1, use the older finite-differences algorithm in the 2018 version of STRAHL.</span>
<span class="sd">            evolneut : bool, optional</span>
<span class="sd">                If True, evolve neutral impurities based on their D,V coefficients. Default is False, in</span>
<span class="sd">                which case neutrals are only taken as a source and those that are not ionized immediately after</span>
<span class="sd">                injection are neglected.</span>
<span class="sd">                This option is NOT CURRENTLY RECOMMENDED, because this method is still under development/</span>
<span class="sd">                examination. </span>
<span class="sd">            use_julia : bool, optional</span>
<span class="sd">                If True, run the Julia pre-compiled version of the code. Run the julia makefile option to set </span>
<span class="sd">                this up. Default is False (still under development)</span>

<span class="sd">        Returns:</span>
<span class="sd">            nz : array, (nr,nZ,nt)</span>
<span class="sd">                Charge state densities [:math::`cm^{-3}`] over the space and time grids.</span>
<span class="sd">            N_wall : array (nt,)</span>
<span class="sd">                Number of particles at the wall reservoir over time.</span>
<span class="sd">            N_div : array (nt,)</span>
<span class="sd">                Number of particles in the divertor reservoir over time.</span>
<span class="sd">            N_pump : array (nt,)</span>
<span class="sd">                Number of particles in the pump reservoir over time.</span>
<span class="sd">            N_ret : array (nt,)</span>
<span class="sd">                 Number of particles temporarily held in the wall reservoirs. </span>
<span class="sd">            N_tsu : array (nt,)</span>
<span class="sd">                 Edge particle loss [:math::`cm^{-3}`]</span>
<span class="sd">            N_dsu : array (nt,)</span>
<span class="sd">                 Parallel particle loss [:math::`cm^{-3}`]</span>
<span class="sd">            N_dsul : array (nt,)</span>
<span class="sd">                 Parallel particle loss at the limiter [:math::`cm^{-3}`]</span>
<span class="sd">            rcld_rate : array (nt,)</span>
<span class="sd">                 Recycling from the divertor [:math::`s^{-1} cm^{-3}`]</span>
<span class="sd">            rclw_rate : array (nt,)</span>
<span class="sd">                 Recycling from the wall [:math::`s^{-1} cm^{-3}`]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># D_z and V_z must have the same shape</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">D_z</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">V_z</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">times_DV</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">D_z</span><span class="o">.</span><span class="n">ndim</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">V_z</span><span class="o">.</span><span class="n">ndim</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;D_z and V_z given as time dependent, but times were not specified!&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">nz_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># default: start in a state with no impurity ions</span>
            <span class="n">nz_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rvol_grid</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Z_imp</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">D_z</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="c1"># set all charge states to have the same transport</span>
            <span class="n">D_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">D_z</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Z_imp</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># include elements for neutrals</span>
            <span class="n">V_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">V_z</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Z_imp</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            
            <span class="c1"># unless specified, set transport coefficients for neutrals to 0</span>
            <span class="n">D_z</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">V_z</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="n">D_z</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># D_z was given as time-independent</span>
            <span class="n">D_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">D_z</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Z_imp</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># include elements for neutrals</span>
            <span class="n">V_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">V_z</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Z_imp</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">times_DV</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]</span> <span class="c1"># dummy, no time dependence</span>

        <span class="c1"># NOTE: for both Fortran and Julia, use f_configuous arrays for speed!</span>
        <span class="k">if</span> <span class="n">use_julia</span><span class="p">:</span>
            <span class="c1"># run Julia version of the code</span>
            <span class="kn">from</span> <span class="nn">julia.api</span> <span class="kn">import</span> <span class="n">Julia</span>
            <span class="n">jl</span> <span class="o">=</span> <span class="n">Julia</span><span class="p">(</span><span class="n">compiled_modules</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">sysimage</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;/../aurora.jl/sysimage.so&quot;</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">julia</span> <span class="kn">import</span> <span class="n">aurora</span> <span class="k">as</span> <span class="n">aurora_jl</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">=</span> <span class="n">aurora_jl</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_out</span><span class="p">),</span>  <span class="c1"># number of times at which simulation outputs results</span>
                                     <span class="n">times_DV</span><span class="p">,</span>
                                     <span class="n">D_z</span><span class="p">,</span> <span class="n">V_z</span><span class="p">,</span> <span class="c1"># cm^2/s &amp; cm/s    #(ir,nt_trans,nion)</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">par_loss_rate</span><span class="p">,</span>  <span class="c1"># time dependent</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">source_rad_prof</span><span class="p">,</span><span class="c1"># source profile in radius</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">S_rates</span><span class="p">,</span> <span class="c1"># ioniz_rate,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">R_rates</span><span class="p">,</span> <span class="c1"># recomb_rate,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">rvol_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pro_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpr_grid</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">mixing_radius</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decay_length_boundary</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">time_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">saw_on</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">source_time_history</span><span class="p">,</span> <span class="c1"># source profile in time</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">save_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sawtooth_erfc_width</span><span class="p">,</span> <span class="c1"># dsaw width  [cm, circ geometry]</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">wall_recycling</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">source_div_fraction</span><span class="p">,</span> <span class="c1"># divbls [fraction of source into divertor]</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">tau_div_SOL_ms</span> <span class="o">*</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_pump_ms</span> <span class="o">*</span><span class="mf">1e-3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_rcl_ret_ms</span> <span class="o">*</span><span class="mf">1e-3</span><span class="p">,</span>  <span class="c1">#[s] </span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">rvol_lcfs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lim_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prox_param</span><span class="p">,</span>
                                     <span class="n">nz_init</span><span class="p">,</span> <span class="n">alg_opt</span><span class="p">,</span> <span class="n">evolneut</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res</span> <span class="o">=</span>  <span class="n">_aurora</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_out</span><span class="p">),</span>  <span class="c1"># number of times at which simulation outputs results</span>
                                    <span class="n">times_DV</span><span class="p">,</span>
                                    <span class="n">D_z</span><span class="p">,</span> <span class="n">V_z</span><span class="p">,</span> <span class="c1"># cm^2/s &amp; cm/s    #(ir,nt_trans,nion)</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">par_loss_rate</span><span class="p">,</span>  <span class="c1"># time dependent</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">source_rad_prof</span><span class="p">,</span><span class="c1"># source profile in radius</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">S_rates</span><span class="p">,</span> <span class="c1"># ioniz_rate,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">R_rates</span><span class="p">,</span> <span class="c1"># recomb_rate,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">rvol_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pro_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpr_grid</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">mixing_radius</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decay_length_boundary</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">time_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">saw_on</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">source_time_history</span><span class="p">,</span> <span class="c1"># source profile in time</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">save_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sawtooth_erfc_width</span><span class="p">,</span> <span class="c1"># dsaw width  [cm, circ geometry]</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">wall_recycling</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">source_div_fraction</span><span class="p">,</span> <span class="c1"># divbls [fraction of source into divertor]</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">tau_div_SOL_ms</span> <span class="o">*</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_pump_ms</span> <span class="o">*</span><span class="mf">1e-3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_rcl_ret_ms</span> <span class="o">*</span><span class="mf">1e-3</span><span class="p">,</span>  <span class="c1"># [s]  </span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">rvol_lcfs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lim_sep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prox_param</span><span class="p">,</span>
                                    <span class="n">rn_t0</span> <span class="o">=</span> <span class="n">nz_init</span><span class="p">,</span>  <span class="c1"># if omitted, internally set to 0&#39;s</span>
                                    <span class="n">alg_opt</span><span class="o">=</span><span class="n">alg_opt</span><span class="p">,</span>
                                    <span class="n">evolneut</span><span class="o">=</span><span class="n">evolneut</span><span class="p">)</span>

        <span class="c1"># nz, N_wall, N_div, N_pump, N_ret, N_tsu, N_dsu, N_dsul, rcld_rate, rclw_rate = self.res</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span></div>
    
        
<div class="viewcode-block" id="aurora_sim.calc_Zeff"><a class="viewcode-back" href="../../aurora.html#aurora.core.aurora_sim.calc_Zeff">[docs]</a>    <span class="k">def</span> <span class="nf">calc_Zeff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Compute Zeff from each charge state density, using the result of an Aurora simulation.</span>
<span class="sd">        The total Zeff change over time and space due to the simulated impurity can be simply obtained by summing </span>
<span class="sd">        over charge states</span>

<span class="sd">        Results are stored as an attribute of the simulation object instance. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># This method requires that a simulation has already been run:</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;res&#39;</span><span class="p">)</span>

        <span class="c1"># extract charge state densities from the simulation result</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Compute the variation of Zeff from these charge states</span>
        <span class="n">Zmax</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Zmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_Zeff</span> <span class="o">=</span> <span class="n">nz</span><span class="o">*</span><span class="p">(</span><span class="n">Z</span><span class="o">*</span><span class="p">(</span><span class="n">Z</span><span class="o">-</span><span class="mi">1</span><span class="p">))[</span><span class="kc">None</span><span class="p">,:,</span><span class="kc">None</span><span class="p">]</span>   <span class="c1"># for each charge state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_Zeff</span><span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ne</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:]</span></div>


        
<div class="viewcode-block" id="aurora_sim.check_conservation"><a class="viewcode-back" href="../../aurora.html#aurora.core.aurora_sim.check_conservation">[docs]</a>    <span class="k">def</span> <span class="nf">check_conservation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Check particle conservation for an aurora simulation.</span>

<span class="sd">        Args : </span>
<span class="sd">            plot : bool, optional</span>
<span class="sd">                If True, plot time histories in each particle reservoir and display quality of particle conservation.</span>
<span class="sd">            axs : matplotlib.Axes instances, optional </span>
<span class="sd">                Axes to pass to :py:meth:`~aurora.particle_conserv.check_particle_conserv`</span>
<span class="sd">                These may be the axes returned from a previous call to this function, to overlap </span>
<span class="sd">                results for different runs. </span>
<span class="sd">        Returns : </span>
<span class="sd">            out : dict</span>
<span class="sd">                Dictionary containing density of particles in each reservoir.</span>
<span class="sd">            axs : matplotlib.Axes instances , only returned if plot=True</span>
<span class="sd">                New or updated axes returned by :py:meth:`~aurora.particle_conserv.check_particle_conserv`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">nz</span><span class="p">,</span> <span class="n">N_wall</span><span class="p">,</span> <span class="n">N_div</span><span class="p">,</span> <span class="n">N_pump</span><span class="p">,</span> <span class="n">N_ret</span><span class="p">,</span> <span class="n">N_tsu</span><span class="p">,</span> <span class="n">N_dsu</span><span class="p">,</span> <span class="n">N_dsul</span><span class="p">,</span> <span class="n">rcld_rate</span><span class="p">,</span> <span class="n">rclw_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># time,nZ,space</span>

        <span class="c1"># Check particle conservation</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">xarray</span><span class="o">.</span><span class="n">Dataset</span><span class="p">({</span><span class="s1">&#39;impurity_density&#39;</span><span class="p">:</span> <span class="p">([</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;charge_states&#39;</span><span class="p">,</span><span class="s1">&#39;rvol_grid&#39;</span><span class="p">],</span> <span class="n">nz</span><span class="p">),</span>
                         <span class="s1">&#39;source_time_history&#39;</span><span class="p">:</span> <span class="p">([</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_time_history</span> <span class="p">),</span>
                         <span class="s1">&#39;particles_in_divertor&#39;</span><span class="p">:</span> <span class="p">([</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">N_div</span><span class="p">),</span> 
                         <span class="s1">&#39;particles_in_pump&#39;</span><span class="p">:</span> <span class="p">([</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">N_pump</span><span class="p">),</span> 
                         <span class="s1">&#39;parallel_loss&#39;</span><span class="p">:</span> <span class="p">([</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">N_dsu</span><span class="p">),</span> 
                         <span class="s1">&#39;parallel_loss_to_limiter&#39;</span><span class="p">:</span> <span class="p">([</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">N_dsul</span><span class="p">),</span> 
                         <span class="s1">&#39;edge_loss&#39;</span><span class="p">:</span> <span class="p">([</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">N_tsu</span><span class="p">),</span> 
                         <span class="s1">&#39;particles_at_wall&#39;</span><span class="p">:</span> <span class="p">([</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">N_wall</span><span class="p">),</span> 
                         <span class="s1">&#39;particles_retained_at_wall&#39;</span><span class="p">:</span> <span class="p">([</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">N_ret</span><span class="p">),</span> 
                         <span class="s1">&#39;recycling_from_wall&#39;</span><span class="p">:</span>  <span class="p">([</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">rclw_rate</span><span class="p">),</span> 
                         <span class="s1">&#39;recycling_from_divertor&#39;</span><span class="p">:</span>  <span class="p">([</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">rcld_rate</span><span class="p">),</span> 
                         <span class="s1">&#39;pro&#39;</span><span class="p">:</span> <span class="p">([</span><span class="s1">&#39;rvol_grid&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pro_grid</span><span class="p">),</span> 
                         <span class="s1">&#39;rhop_grid&#39;</span><span class="p">:</span> <span class="p">([</span><span class="s1">&#39;rvol_grid&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhop_grid</span><span class="p">)</span>
                         <span class="p">},</span>
                        <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_out</span><span class="p">,</span> 
                                <span class="s1">&#39;rvol_grid&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rvol_grid</span><span class="p">,</span>
                                <span class="s1">&#39;charge_states&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                                <span class="p">})</span>

        <span class="k">return</span> <span class="n">particle_conserv</span><span class="o">.</span><span class="n">check_particle_conserv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Raxis</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">axs</span><span class="o">=</span><span class="n">axs</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, F.Sciortino

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>